WEBVTT
Kind: captions
Language: en

00:00:00.950 --> 00:00:06.769
&gt;&gt;Now let's look at zero and unit indexing
and while loops. First let's talk a little

00:00:06.769 --> 00:00:11.379
bit about counting. Suppose you were running
a race, and you were supposed to go three

00:00:11.379 --> 00:00:17.290
laps around the track. What happens if you
say one as you're leaving the blocks? Well

00:00:17.290 --> 00:00:24.290
this is basically unit indexing. So you leave
the blocks and you say one, you go around

00:00:24.480 --> 00:00:31.480
the track once, whoop! That's two. Then you
go around the track a second time, and that's

00:00:33.160 --> 00:00:39.730
three. So you've counted to three, but you've
only done two loops around the track. That

00:00:39.730 --> 00:00:44.190
is a problem. Won't win many races that way.

00:00:44.190 --> 00:00:49.260
So let's talk about a pattern that's called
unit indexing. Suppose you want to write a

00:00:49.260 --> 00:00:56.260
loop that prints out one, two, three. Well,
let's trace the code below. We have int count

00:00:56.720 --> 00:01:02.399
as one, and then we say while counts as less
than or equal to three. In the loop we'll

00:01:02.399 --> 00:01:09.020
print out count, and then we'll increment
count by one. Well here's what happens when

00:01:09.020 --> 00:01:14.869
you trace this loop. Count is one initially,
count less than or equal to three is true,

00:01:14.869 --> 00:01:19.079
so you go into the loop, so you print out
one and then you increment count from one

00:01:19.079 --> 00:01:26.079
to two. So that puts us at this point in the
table. Then, count is still less than or equal

00:01:26.709 --> 00:01:33.709
to three, so you go into the loop again, you
print out two and you increment count to three.

00:01:34.100 --> 00:01:38.289
So right here we are in the table when count
is three.

00:01:38.289 --> 00:01:43.599
Now count less than or equal to three is still
true. So you go into the loop again, you print

00:01:43.599 --> 00:01:49.310
out three and then you say count is count
plus one. So count actually ends with a value

00:01:49.310 --> 00:01:56.270
of four at the end of this loop, even though
it printed out one, two, three successfully.

00:01:56.270 --> 00:02:01.849
That's an interesting problem. Now let's look
at a second pattern. This pattern is called

00:02:01.849 --> 00:02:06.630
zero indexing. We're doing the same thing.
We're trying to print out one, two, three

00:02:06.630 --> 00:02:08.979
and we're going to trace the code again.

00:02:08.979 --> 00:02:14.349
So we start with count as zero and then we
look at wow count is less than three. Now

00:02:14.349 --> 00:02:18.959
this time we have to increment count first,
because the first thing we wanted to print

00:02:18.959 --> 00:02:24.480
out is one and right now count has the value
of zero. So we increment count to one and

00:02:24.480 --> 00:02:31.099
then print it out and that's what we repeat.
If we trace the loop now we'll see count starts

00:02:31.099 --> 00:02:37.530
at zero, gets incremented to one in the first
trip through the loop, then we print out one,

00:02:37.530 --> 00:02:42.189
then we check to see if count is less than
three, which it is, because one is less than

00:02:42.189 --> 00:02:48.730
three. Then count gets incremented to two,
we print out two. We say while two is less

00:02:48.730 --> 00:02:55.730
than three. Well that's true, so count get's
incremented to three and we print out count

00:02:55.939 --> 00:02:58.079
being three.

00:02:58.079 --> 00:03:03.170
So there we have it. We're still printing
out one, two, three, but we're doing it differently.

00:03:03.170 --> 00:03:08.219
Now what I want you to pay attention to is
the pattern between these codes. So we started

00:03:08.219 --> 00:03:14.859
with count as zero and we ended with count
less than three when we were zero indexing,

00:03:14.859 --> 00:03:20.569
whereas with unit indexing we started with
count as one and we ended with count less

00:03:20.569 --> 00:03:26.799
than or equal to three. That's a pattern that's
worth remembering.

00:03:26.799 --> 00:03:31.680
One thing you may be wondering is why did
I stop at three? Well there's very good reason

00:03:31.680 --> 00:03:36.999
for this. When you start tracing a loop more
than three or four times, it's really easy

00:03:36.999 --> 00:03:42.150
to lose track of where you are and then you
just can't be accurate enough. So the reason

00:03:42.150 --> 00:03:47.989
I like three is you have an initial iteration,
sort of a middle one and then a last one,

00:03:47.989 --> 00:03:52.849
and that seems to show up most problems that
are in loops. And so that's why you'll see

00:03:52.849 --> 00:03:59.319
me use threes a lot when I'm working on examples.
The technique that I use to figure out what

00:03:59.319 --> 00:04:03.659
the loops are doing is called tracing code,
and this is another way that we visualize

00:04:03.659 --> 00:04:10.040
how programs work. Each column records the
value in one variable as they change over

00:04:10.040 --> 00:04:15.590
time. So one of the things that's nice about
tracing code versus memory diagrams is with

00:04:15.590 --> 00:04:20.780
tracing code you actually se the changes over
time a little bit more clearly. Sometimes

00:04:20.780 --> 00:04:26.200
in memory diagrams when you start crossing
things out, it gets a little bit messy.

00:04:26.200 --> 00:04:30.540
The value at the bottom is the current value,
so that's the one for example when the loop

00:04:30.540 --> 00:04:35.890
ends. Now it's hard to be accurate for more
than a few iterations, so I don't recommend

00:04:35.890 --> 00:04:41.110
that you hand-trace things to go through ten
or twenty iterations-- I certainly couldn't

00:04:41.110 --> 00:04:46.610
be accurate enough. Instead, cut it back to
a smaller number of iterations and pay attention

00:04:46.610 --> 00:04:52.950
to the pattern. If the pattern is the same
you'll still be able to pick up the errors.

00:04:52.950 --> 00:04:58.450
So here are some general observations. Unit
indexing starts at one. Remember when we use

00:04:58.450 --> 00:05:04.480
the word unit in the mathematic sense, it
means one. It ends with less than or equal

00:05:04.480 --> 00:05:10.470
to the goal, which in this case was three.
But when you end the counter is going to be

00:05:10.470 --> 00:05:15.640
one larger than the goal, and that can be
a problem sometimes. Sometimes we want to

00:05:15.640 --> 00:05:20.790
use those counters later, and having them
a little bit too large doesn't help.

00:05:20.790 --> 00:05:26.150
Now with zero indexing we start at zero and
we end with less than the goal, which again

00:05:26.150 --> 00:05:32.470
was three, but the counter equals the goal
at the end. And so that's kind of a nice thing.

00:05:32.470 --> 00:05:39.440
This is one of the reasons that computer scientists
tend to prefer zero indexing over unit indexing.

00:05:39.440 --> 00:05:44.660
But I do want to point out that most loops
can be done successfully either way. Also

00:05:44.660 --> 00:05:49.160
pay attention to the fact that we had to change
the order of incrementing the counter, so

00:05:49.160 --> 00:05:53.180
you still have to pay attention to all of
those minute details that you're always for

00:05:53.180 --> 00:05:55.870
in loops.

00:05:55.870 --> 00:06:01.740
Now this is part of something computer science,
a big part of the culture. It's called a OBOB.

00:06:01.740 --> 00:06:07.130
And yes that really is what everybody calls
it. This stands for Off By One Bug. Now this

00:06:07.130 --> 00:06:13.000
can be a very hard mistake to find and it's
incredibly common. In fact it's one of the

00:06:13.000 --> 00:06:17.690
most common mistakes people make when they're
writing loops. What it means is you go through

00:06:17.690 --> 00:06:24.690
the loop one too many times or one too few
times, something other than the right number.

00:06:25.010 --> 00:06:31.030
So either way, going through one too many
or one too few really is a big problem.

00:06:31.030 --> 00:06:36.150
Now computer scientists are absolutely insane
about how important this is, and the reason

00:06:36.150 --> 00:06:41.240
that we're so insane about it is because it
causes so much trouble in software. So this

00:06:41.240 --> 00:06:46.100
is something you definitely want to pay attention
to every time you write a loop. In fact I

00:06:46.100 --> 00:06:50.530
recommend that you do a little bit of tracing
before you even run the program to see if

00:06:50.530 --> 00:06:55.390
it's working correctly. I know that sounds
like it's a lot of work, sometimes it's easier

00:06:55.390 --> 00:07:00.880
to trace things first than it is to debug
them after they're done. So keep programming!

