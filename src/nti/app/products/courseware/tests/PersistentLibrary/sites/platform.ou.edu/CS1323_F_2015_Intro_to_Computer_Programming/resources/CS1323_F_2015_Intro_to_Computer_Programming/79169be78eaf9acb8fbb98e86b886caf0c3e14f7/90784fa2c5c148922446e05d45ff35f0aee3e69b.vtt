WEBVTT
Kind: captions
Language: en

00:00:01.550 --> 00:00:07.220
&gt;&gt;Let's continue our study of methods and
references by refining search. Here's the

00:00:07.220 --> 00:00:12.310
problem statement: e-commerce sites often
permit you to start an initial search and

00:00:12.310 --> 00:00:14.849
then
refine it. That is, to be more and more specific

00:00:14.849 --> 00:00:19.659
about exactly what it is that you would like.
So for example, if we go to Land's End we'll

00:00:19.659 --> 00:00:26.659
see that the check boxes on the left are
actually search refinements. So here we are

00:00:26.699 --> 00:00:33.699
at the Land's End site. Notice that I've picked
women's shirts and blouses. If for example,

00:00:34.050 --> 00:00:38.649
I choose only things that come in
regular sizes, we're refining the search.

00:00:38.649 --> 00:00:44.079
That is we're finding a more and more specific
search. I could then, for example, only want

00:00:44.079 --> 00:00:48.719
things with three-quarter length sleeves.
You'll notice that the relationship between

00:00:48.719 --> 00:00:53.539
size range and sleeve length is actually an
and relationship. It's looking for things

00:00:53.539 --> 00:00:59.309
that fall into both of those categories, whereas
if I check that I want three-quarter length

00:00:59.309 --> 00:01:05.309
sleeves or long sleeves, we have an or relationship
going on. So you have both and's and or's

00:01:05.309 --> 00:01:11.420
working on this site. If, for example, I uncheck
that box it's taking me back to a previous

00:01:11.420 --> 00:01:18.270
search. So search refinement is actually a
very important and interesting problem. So

00:01:18.270 --> 00:01:22.620
let's write a program that allows the user
to search string data stored in a file and

00:01:22.620 --> 00:01:27.750
repeatedly refine the search, one word at
a time. Of course our first question is what

00:01:27.750 --> 00:01:33.040
our test data is going to be. Once again I
went to Project Gutenberg and I wanted a nice,

00:01:33.040 --> 00:01:38.070
long book that should provide sufficient data.
I picked "Little Women" this time by Louisa

00:01:38.070 --> 00:01:43.910
May Alcott, but you could pick something different.
So we certainly want to search for words that

00:01:43.910 --> 00:01:48.410
are in the book. We could use things like
the main characters names for example, and

00:01:48.410 --> 00:01:52.690
we can search for words that aren't in the
book, so any modern word will work well there

00:01:52.690 --> 00:01:57.490
because this is a relatively old book. My
personal plan is to search for computer because

00:01:57.490 --> 00:02:01.920
they didn't have computers back then. Now
the next thing we want to consider is whether

00:02:01.920 --> 00:02:07.360
case matters or not. We could implement the
program either way. If we decide that we do

00:02:07.360 --> 00:02:12.110
not want the program to be case-sensitive
what we should do is store all the data in

00:02:12.110 --> 00:02:16.610
either lowercase and uppercase, and then do
all of our searches in either lowercase or

00:02:16.610 --> 00:02:21.870
uppercase. In this case though, I'm going
to leave it as being case sensitive. So our

00:02:21.870 --> 00:02:26.470
searches will in fact be sensitive to case.
Now these are things you have to think through

00:02:26.470 --> 00:02:31.700
in every different application. This may not
be the right decision for example for a website

00:02:31.700 --> 00:02:37.870
search, where you want to bring up as many
things as possible to help the user find them.

00:02:37.870 --> 00:02:41.670
The methods we're going to need to do this
are ones that are familiar from previous programs

00:02:41.670 --> 00:02:46.960
we've written. For example, we certainly can
read the data from a file and we went to be

00:02:46.960 --> 00:02:51.480
able to display the results. In the sample
code that I wrote for you I used a for each

00:02:51.480 --> 00:02:55.650
loop for that just so you could get a little
bit more experience seeing those in action.

00:02:55.650 --> 00:03:02.200
It's a very nice kind of loop for something
like that, and we need a method for the user

00:03:02.200 --> 00:03:06.690
interface. Now I called this perform search
refinement. So it needs the data and it also

00:03:06.690 --> 00:03:12.290
needs the scanner object so it can interact
with the user. The only really interesting

00:03:12.290 --> 00:03:16.780
method here is the search method. So it's
going to take the ArrayList called source

00:03:16.780 --> 00:03:22.930
and look for the target string. So let's go
and write that method. Here we are in Eclipse

00:03:22.930 --> 00:03:27.209
and notice we've got our search method up
here, so we're going to want to step through

00:03:27.209 --> 00:03:32.349
this array one index at a time. Now I am going
to do did this based on indices although there

00:03:32.349 --> 00:03:37.630
are other ways this code could be written.
If we find something that doesn't contain

00:03:37.630 --> 00:03:42.860
the target, we want to remove it from the
source that way we don't have it to work from.

00:03:42.860 --> 00:03:49.860
We'll have an int index which is initialized
to zero and we'll let the loop repeat as long

00:03:49.950 --> 00:03:56.950
as index is less than source.size and if source,
you know what, I'm not going to write it that

00:04:01.030 --> 00:04:06.130
way. I'm going to write it a little simpler
way. I'm going to create a string that I call

00:04:06.130 --> 00:04:13.130
line and do source.get of index. Now the reason
I'm doing it this way is because I've found

00:04:13.830 --> 00:04:20.169
that students have a lot more success doing
one thing on one line. So when you start nesting

00:04:20.169 --> 00:04:24.990
complicated expressions within each other
it gets really easy to lose track of which

00:04:24.990 --> 00:04:31.169
object is of which type. So by declaring a
reference line and storing the reference in

00:04:31.169 --> 00:04:37.689
there, we are actually able to see that this
is a string object really obviously and I've

00:04:37.689 --> 00:04:41.659
found that people who write code this way
tend to have better success. So let's stick

00:04:41.659 --> 00:04:48.659
with this. So if line.contains target well
now, let's think about it. Do we want to do

00:04:52.059 --> 00:04:56.439
something when line contains target or when
it doesn't? I think what we want to do is

00:04:56.439 --> 00:05:03.439
remove when line doesn't contain target, so
let's put a not in front of that, and what

00:05:03.559 --> 00:05:10.559
we're going to do here is source.remove at
the given index. Now we need to think carefully

00:05:11.039 --> 00:05:16.479
about what we should do next. I think most
people if they wrote this code alone and by

00:05:16.479 --> 00:05:20.729
the way, certainly the first time I wrote
it would just have done this-- set index equals

00:05:20.729 --> 00:05:27.289
index +1. But you need to be a little careful,
because we are removing something at the index

00:05:27.289 --> 00:05:32.300
from source that means that things at the
larger indices are going to be shifted over

00:05:32.300 --> 00:05:37.169
and are going to fill in that spot. So in
the case when we remove something we do not

00:05:37.169 --> 00:05:41.949
want to increment the index. We're going to
need to check that same index again, because

00:05:41.949 --> 00:05:47.740
now there's a different value in it. So what
I'm trying to say here is that this belongs

00:05:47.740 --> 00:05:54.740
in an else statement, and of course whoops!
That would be a silly thing to do wouldn't

00:05:59.610 --> 00:06:04.900
it? [laughs] So now we're incrementing once
but only when the data item isn't removed.

00:06:04.900 --> 00:06:09.389
So that looks pretty good. Now at this point
we probably should test the program, but I

00:06:09.389 --> 00:06:13.889
have bigger fish to fry so I'm going to go
on and do something else. Just remember, testing

00:06:13.889 --> 00:06:18.400
more often is going to make it easier to debug
your programs. So if you are doing this on

00:06:18.400 --> 00:06:23.919
your own this is definitely a time you would
not want to skip testing. Now there's a serious

00:06:23.919 --> 00:06:29.229
shortcoming with this program, and that's
the user can't go back to a previous result.

00:06:29.229 --> 00:06:35.089
And that is an extremely useful thing to be
able to do. So the problem here is that we

00:06:35.089 --> 00:06:39.629
have only one ArrayList of string object,
so let's take a look at what the parameter

00:06:39.629 --> 00:06:44.740
passing looks like right now using a memory
diagram. So we're looking at the parameter

00:06:44.740 --> 00:06:51.740
passing between the main method and the search
method. So here is the memory diagram. Notice

00:06:52.199 --> 00:06:57.159
in the main method we have one reference data
that points to the ArrayList that's in the

00:06:57.159 --> 00:07:01.860
heap. Remember that the heap is where all
the extra memory is and so that's where all

00:07:01.860 --> 00:07:06.460
of our items get constructed from. So we've
got our ArrayList. Now I've just put some

00:07:06.460 --> 00:07:11.759
sample data in here 1, 2, 3, 4, that wouldn't
be the real data because of course those wouldn't

00:07:11.759 --> 00:07:17.039
come out of the same search. So we have the
references to the strings. Now in the search

00:07:17.039 --> 00:07:24.039
method we have a reference called source and
it points to that same ArrayList. So the main

00:07:24.119 --> 00:07:28.990
method and the search method are both using
the same ArrayList. So when we make changes

00:07:28.990 --> 00:07:34.830
in the search method, that means that the
main method's version of this ArrayList also

00:07:34.830 --> 00:07:39.909
gets changed. In other words-- once we've
removed things in the search list they're

00:07:39.909 --> 00:07:43.860
gone in the main method too. Now the reason
that is true is because of these arrows, the

00:07:43.860 --> 00:07:50.860
arrow right here and the arrow right here
that show us that both of these methods are

00:07:51.369 --> 00:07:58.149
using the same object, even though have they
have different references. So what we're doing

00:07:58.149 --> 00:08:04.860
in this program is we're passing the ArrayList
of string by reference. When an object's reference

00:08:04.860 --> 00:08:10.689
is passed to a method, both of the methods
share the object. You saw that in the diagram.

00:08:10.689 --> 00:08:15.749
Now this sharing ends if a constructor gets
called and you can see that later too. Now

00:08:15.749 --> 00:08:21.800
this is very efficient for memory usage because
references are teeny, teeny, teeny, tiny.

00:08:21.800 --> 00:08:25.899
ArrayLists on the other hand can be really
big. The problem in this case it makes it

00:08:25.899 --> 00:08:31.270
impossible to backup, because once we've removed
elements from that ArrayList they're gone

00:08:31.270 --> 00:08:37.329
forever. So the next thing we need to do to
create a backup feature is we need to store

00:08:37.329 --> 00:08:42.269
the previous ArrayList objects. So we're going
to use an array for this. Now this is kind

00:08:42.269 --> 00:08:47.110
of an unusual design decision and I'll explain
why a little bit later, but we're in a chapter

00:08:47.110 --> 00:08:53.480
on arrays so certainly array has to be involved
somewhere. So if we have an ArrayList of string

00:08:53.480 --> 00:08:59.230
called previous searches, here's how we construct
it. This construction is a little bit weird.

00:08:59.230 --> 00:09:04.310
This is a very strange Java quirk. And that
is that you give the generic on the left-hand

00:09:04.310 --> 00:09:08.660
side when you're declaring previous searches
but you don't give it on the right-hand side

00:09:08.660 --> 00:09:13.620
when you're calling the constructor. Now this
is something that is completely unanticipated.

00:09:13.620 --> 00:09:16.690
This is something that you never would have
guessed and by the way, if you are doing a

00:09:16.690 --> 00:09:21.449
test I wouldn't take off any points for making
a mistake like putting the generic in here,

00:09:21.449 --> 00:09:25.649
because that really would make sense. This
is something that you'll learn in your next

00:09:25.649 --> 00:09:30.519
course on Java and eventually this will make
sense but for right now just trust me that

00:09:30.519 --> 00:09:34.370
that's the way this is supposed to be done.
So notice here I've declared the reference

00:09:34.370 --> 00:09:39.810
previous searches and I've also constructed
an array to a fixed size. You can tell it's

00:09:39.810 --> 00:09:46.240
a constant because it's in all caps. Now when
we do a new search we need to save the previous

00:09:46.240 --> 00:09:52.480
ArrayList string to the array. Now that's
going to change the signature of the ArrayList

00:09:52.480 --> 00:09:59.480
method because now we need to return that
ArrayList too. Now as we go to implement this,

00:09:59.889 --> 00:10:04.540
we need to make sure we understand exactly
when we're going to put things into and take

00:10:04.540 --> 00:10:09.430
things out of the array. There are actually
two different ways it could be done. One choice

00:10:09.430 --> 00:10:14.629
would be to put in all the searches immediately
when you do them. The other choice is to put

00:10:14.629 --> 00:10:20.209
the previous search into the array just when
you do the next search. Now either one of

00:10:20.209 --> 00:10:25.000
these can be done correctly, but where you're
going to get in trouble is when you do a hybrid:

00:10:25.000 --> 00:10:29.379
when you sometimes do it one way and other
times do it the other way, so it's important

00:10:29.379 --> 00:10:33.839
to have a plan going in. Now the plan I'm
going to use is putting the previous search

00:10:33.839 --> 00:10:38.579
in when the next search is done. Like I say
neither one of these choices is better, it's

00:10:38.579 --> 00:10:45.060
just important that we're consistent. We're
going to go to our search method and change

00:10:45.060 --> 00:10:52.060
the return type. So now we want to return
an ArrayList of strings. Now to make the compiler

00:10:52.509 --> 00:10:59.509
happy, we'll return source. The other thing
we need to do is we need to update our Javadoc.

00:11:03.629 --> 00:11:07.639
One of the problems you run into when you
start making changes to code like this, which

00:11:07.639 --> 00:11:12.899
is basically code maintenance, is that it's
very easy to forget to change the documentation

00:11:12.899 --> 00:11:17.519
and when you do that then your documentation
doesn't match your code. There's a saying

00:11:17.519 --> 00:11:22.100
in computer science that when your documentation
doesn't match your code, they're usually both

00:11:22.100 --> 00:11:27.639
wrong. Now what we mean by that is that when
those two things get out of sync it means

00:11:27.639 --> 00:11:31.339
that when you were writing the code you weren't
paying careful attention, and if you're not

00:11:31.339 --> 00:11:36.209
paying careful attention when you're writing
code to details like the documentation it's

00:11:36.209 --> 00:11:40.529
likely that you made mistakes writing it.
Now of course we're being a little sarcastic

00:11:40.529 --> 00:11:47.529
with this but it is actually something to
consider. So we're going to return the source

00:11:49.440 --> 00:11:56.440
array with only strings that contain target.
So there we go. Now our documentation matches

00:12:02.629 --> 00:12:08.120
our search and we're happy. Now the other
thing we need to think about is how we're

00:12:08.120 --> 00:12:15.120
going to change our user interface. So first
we need to find our user interface...and it's

00:12:15.519 --> 00:12:22.519
right down here at the bottom. It's called
perform search refinement. So you'll notice

00:12:23.850 --> 00:12:29.060
that I created a constant, now I just put
it in this method because this is going to

00:12:29.060 --> 00:12:34.259
be our whole user interface and so this is
a good place to have that. We don't need to

00:12:34.259 --> 00:12:38.089
have it in the main program. If you put it
in the main program remember you'll have to

00:12:38.089 --> 00:12:43.279
pass it in as a parameter. Then I did the
construction here, just like I showed you

00:12:43.279 --> 00:12:48.209
on the previous slide. Notice that we are
missing the generic here and Eclipse is giving

00:12:48.209 --> 00:12:52.790
us a little warning about that. The other
thing to notice is we need to keep track of

00:12:52.790 --> 00:12:57.370
the size of elements in the array by ourselves.
It's not like an ArrayList where all that

00:12:57.370 --> 00:13:03.149
gets stored, this time we have to keep track.
So I created a string called answer, it's

00:13:03.149 --> 00:13:08.040
going to get input from the user. I initialized
it to yes to get us into the loop the first

00:13:08.040 --> 00:13:13.550
time. I've got some little comments here that
you may read. Basically when the logic gets

00:13:13.550 --> 00:13:18.189
complicated, more documentation is a good
idea. If we get into the loop what we want

00:13:18.189 --> 00:13:23.399
to do is ask the user if they want to refine
the search or go back and then we read that

00:13:23.399 --> 00:13:28.939
from the user. If the answer isn't back then
we're going to need to do something to refine

00:13:28.939 --> 00:13:35.339
the search. Otherwise if the answer is back,
then we need to go back. Now I had commented

00:13:35.339 --> 00:13:40.800
out the search previously because I changed
the signature on it and I didn't want it to

00:13:40.800 --> 00:13:46.230
put up error messages when we were writing
the search method. So there's our search,

00:13:46.230 --> 00:13:51.790
so let's think about what we want to do. Well
the first thing we need to think about is

00:13:51.790 --> 00:13:58.769
putting things into the array. So the array
is called previous searches and we're going

00:13:58.769 --> 00:14:05.769
to be setting the value at size to data. So
this way we're storing the reference data

00:14:05.930 --> 00:14:12.930
in our previous searches array. And of course,
size is going to equal size +1. Now whenever

00:14:14.839 --> 00:14:20.069
you write code with an array you have to be
very careful to not step off the end. Arrays

00:14:20.069 --> 00:14:25.110
are different than ArrayLists. Arrays do not
reconstruct the array to a larger size like

00:14:25.110 --> 00:14:32.110
ArrayLists do. So really we need to put a
guard in here and that is-- if the size is

00:14:36.720 --> 00:14:43.720
less than size. Now let's think about that.
If we have size -1 we can put the data in

00:14:45.209 --> 00:14:52.209
there and so that actually works. Now we also
have to think about what we're going to do

00:14:54.569 --> 00:15:01.569
if this doesn't work. Now we could have a
lot of complicated strategies, but I think

00:15:01.810 --> 00:15:08.810
the easiest one in this case-- and let's make
a comment here that there's enough space in

00:15:10.879 --> 00:15:17.879
the array, no more space in the array. Really
the only thing we can do at this point is

00:15:27.749 --> 00:15:34.749
let the user know what's going on [typing].
We probably don't want to refuse to let them

00:15:40.559 --> 00:15:45.759
do their search, so we're going to mess with
the backup, but at least they'll still be

00:15:45.759 --> 00:15:50.800
able to do their search. So they do their
search and then they return the result. Now

00:15:50.800 --> 00:15:56.660
let's think about what happens if they're
going back. Well what we're going to do is

00:15:56.660 --> 00:16:03.660
data equals previous searches of size -1.
And then size equals size-1. There's one other

00:16:10.300 --> 00:16:17.300
thing that we should really do here, and that's
previous searches of size minus one equals

00:16:21.850 --> 00:16:28.850
null. I'm going to move this line up one line
since we had change size, we need to be careful

00:16:29.670 --> 00:16:36.670
to use the old size. What that does is it
takes the array reference that was stored

00:16:38.410 --> 00:16:44.050
in previous searches and it removes it. Now
that turned out to be important because Java

00:16:44.050 --> 00:16:49.490
garbage collects things only when there are
no references to it. So if you don't do that

00:16:49.490 --> 00:16:53.809
what happens is some ArrayLists will get left
in memory that shouldn't be. These are subtle

00:16:53.809 --> 00:16:57.370
things and things that are hard to learn,
but it is part of becoming a professional

00:16:57.370 --> 00:17:03.709
and doing this. So in this case we go back
to our previous search, we set that value

00:17:03.709 --> 00:17:10.060
to null, decrease the size so that we keep
the size correct, and then we're going to

00:17:10.060 --> 00:17:15.380
let it go around again. So basically we don't
do a search in this, the returning back one

00:17:15.380 --> 00:17:20.950
is the function of this part of the code.
Then we ask the user if they want to continue.

00:17:20.950 --> 00:17:26.100
So this is all looking good except for one
thing, and that is-- how do we know that this

00:17:26.100 --> 00:17:32.040
size -1 is legal? Like I say every time you
put an index in an array, you have to think

00:17:32.040 --> 00:17:37.790
to yourself how do I know that size is at
least one? Well in this case you really don't

00:17:37.790 --> 00:17:43.790
and so what we need to do is put a guard in
it. So if size is greater than or equal to

00:17:43.790 --> 00:17:49.090
one you also could say if size is greater
than zero if you like that better, than these

00:17:49.090 --> 00:17:56.090
get indented. If size is not bigger than that,
then we need to let the user know. So we'll

00:18:00.290 --> 00:18:07.290
give them some feedback again. There is no
previous data to go back to. You always want

00:18:10.910 --> 00:18:15.290
to keep the user in the loop and let them
see what's happening. There we have a nice

00:18:15.290 --> 00:18:20.450
little group of code using an array. By the
way, this is very typically something that

00:18:20.450 --> 00:18:26.060
is done with an array. The reason is because
arrays are fixed in size, it really does make

00:18:26.060 --> 00:18:30.560
sense here to keep this fixed. It's very unlikely
that somebody's going to go more than 10 levels

00:18:30.560 --> 00:18:37.520
deep in a search and so this really makes
good sense. So let's run our program. Now

00:18:37.520 --> 00:18:44.520
I'm going to do our test on the file called
Little Women excerpt. If I can spell it correctly,

00:18:51.290 --> 00:18:55.680
anyways. What I did with this was that I just
took the chapter headings out and so that

00:18:55.680 --> 00:19:02.680
gives me a nice reasonable search to follow.
So let's search for 20. That looks good. All

00:19:03.550 --> 00:19:10.270
those lines actually have 20. Then let's continue
and search for 2, that should give us just

00:19:10.270 --> 00:19:17.270
one line the one with 22 on it. And let's
continue and let's search for computer. So

00:19:20.080 --> 00:19:24.710
this is something that isn't going to be in
it. Now you'll see one shortcoming with our

00:19:24.710 --> 00:19:29.210
user interaction and that's that we didn't
give the user any feedback when there was

00:19:29.210 --> 00:19:34.190
nothing in the search. So that's a problem,
we're going to want to fix that one, but let's

00:19:34.190 --> 00:19:41.190
keep testing. So let's continue and then go
back. Now notice after we went back we also

00:19:42.090 --> 00:19:49.090
didn't display the result and that's something
else we want to fix. So let's go back and

00:19:49.880 --> 00:19:56.880
do a search for 2 again. So somehow our back
isn't it working correctly, so we're going

00:20:01.830 --> 00:20:08.830
to need to debug that. So let's stop the program
and let's fix some things. So first off, after

00:20:13.940 --> 00:20:20.940
we go back we want to show the result for
data, because it's not fair to the user to

00:20:23.680 --> 00:20:27.860
not see where they're working from. And notice
that was causing us, or may have been causing

00:20:27.860 --> 00:20:34.800
us some problems in debugging. The other thing
we wanted to do is to change our display method

00:20:34.800 --> 00:20:40.380
so that when there is no data displayed we
actually say something to the user. So this

00:20:40.380 --> 00:20:47.380
is the show results method. So let's fix that
one too. If data.size = 0 system outprint

00:20:49.940 --> 00:20:56.940
line there are no results to display. In fact,
we could even return at that point if we wanted

00:21:01.460 --> 00:21:08.460
to. So there's some nice code for that. So
we fixed a couple of things, let's go and

00:21:13.130 --> 00:21:20.130
do some debugging or sorry, let's go and do
some testing. So we're going to do 20, and

00:21:31.670 --> 00:21:38.380
that's working correctly. We do want to continue.
Let's do our search for 2. That's working

00:21:38.380 --> 00:21:43.650
correctly. We want to continue. Now we're
going to do our search that won't give us

00:21:43.650 --> 00:21:48.640
any result. Notice it says there are no results
to display, so that really is very helpful.

00:21:48.640 --> 00:21:55.640
We do want to continue so let's go back. Now
it still has no results to display. Let's

00:21:56.710 --> 00:22:03.710
try it one more time. So something's going
wrong there. Somehow our backup features isn't

00:22:06.560 --> 00:22:11.850
working quite right. So let's go to the search
refinement method and see if we can find what

00:22:11.850 --> 00:22:18.540
the problem is. So when the answer isn't back,
we go and do another search. Now it looks

00:22:18.540 --> 00:22:23.790
to me like that's going correctly. Let's make
sure we've got our size initialized correctly

00:22:23.790 --> 00:22:30.790
at the start, which we did. So that looks
good. So data is previous searches of size

00:22:32.190 --> 00:22:39.190
-1. Ahhh, I see the problem. Look what I forgot.
When we do previous searches, remember size

00:22:44.640 --> 00:22:50.930
is unit indexed and the indices are zero indexed.
So basically we were storing the data in the

00:22:50.930 --> 00:22:55.750
wrong place, and that's why were having difficulty
finding it. We've stored it one position out

00:22:55.750 --> 00:23:00.140
further than we should have. So we should
have stored it in previous searches if size

00:23:00.140 --> 00:23:07.140
-1, and then incremented size. Then notice
here we'd be retrieving it from size -1. So

00:23:09.260 --> 00:23:13.730
as always, it's the boundary conditions that
kill you in programming. Let's run the program

00:23:13.730 --> 00:23:20.730
again and see if things are working better.
So this will be Little Women excerpt.txt.

00:23:28.940 --> 00:23:35.940
So we'll search for 20 again. Uh oh! And now
we've got a problem. So notice when size is

00:23:38.830 --> 00:23:44.290
0, we've got an issue. So that's the first
thing that broke. So we need to think little

00:23:44.290 --> 00:23:51.290
bit about our logic here. When size is 0,
we want to put it at size of 0. Hmm. So maybe

00:23:58.300 --> 00:24:03.990
that wasn't where our problem was. Let's think
through the whole problem. So let's put it

00:24:03.990 --> 00:24:10.730
size of 0 and then size goes up to 1. So when
we're retrieving it, do we retrieve it from

00:24:10.730 --> 00:24:17.730
size -1? Well we would retrieve from size
of 0, which would be size -1. Hmm, so that's

00:24:20.410 --> 00:24:27.410
kind of strange. I wonder what's going wrong.
So here when we put it in we go to size of

00:24:32.660 --> 00:24:39.660
zero. Then we create a new search. Here when
size is one we'd be pulling out of size of

00:24:45.430 --> 00:24:52.430
0. Well, isn't that interesting. So what I'm
doing right now is just carefully reading

00:24:59.120 --> 00:25:03.960
the code and thinking through every line to
make sure we're doing the right thing. So

00:25:03.960 --> 00:25:10.320
if we're refining our search and our size
is less than size, so this would mean size

00:25:10.320 --> 00:25:15.660
-1 would be the biggest thing that could go
through here. That would be correct. Then

00:25:15.660 --> 00:25:22.660
we would say previous searches of size is
data, that looks correct size equals size

00:25:23.990 --> 00:25:29.990
+1. Anytime we add something in we're going
to have to add 1 to size so that looks correct

00:25:29.990 --> 00:25:35.040
then we do our search. Now remember I'm making
the decision to only store something if we're

00:25:35.040 --> 00:25:40.380
going to actually do another search, but I
think I've been pretty consistent with that.

00:25:40.380 --> 00:25:46.540
So now if size is greater than or equal to
one we get the data from size -1, that really

00:25:46.540 --> 00:25:53.540
looks correct. And then we set previous searches
of size -1 to null. Now you might think that's

00:25:55.710 --> 00:26:01.470
a problem but remember because we've already
put the reference into data that looks okay.

00:26:01.470 --> 00:26:08.470
So maybe it's time to do a little debugging
and see what's going on. So here we are in

00:26:12.650 --> 00:26:19.650
our debugger. We suspect that this is where
the problem is. Where do we want to put our

00:26:24.450 --> 00:26:31.450
stop? I think maybe right about line 142.
So notice I've set a breakpoint there and

00:26:33.230 --> 00:26:37.540
now I'm going to run a program again. Remember
that I'm going to pick the debugger to run

00:26:37.540 --> 00:26:44.540
the program. So this is little, whoops! Better
get the capitalization right. So we're going

00:26:49.530 --> 00:26:56.530
to do 20. We want to continue and then we
were going to go to 2 and we wanted to continue.

00:27:03.280 --> 00:27:10.280
And then we were going to search for something
that isn't there, and we want to continue

00:27:10.370 --> 00:27:17.370
and then we go back. And right here we are.
So here is data. And notice there's nothing

00:27:24.230 --> 00:27:30.710
in it. You can actually see the contents of
data here. Now previous searches, on the other

00:27:30.710 --> 00:27:37.710
hand, has 3 ArrayLists in it. Let's take a
look at this one. This one is element data,

00:27:42.660 --> 00:27:49.660
and if you look very carefully you're going
to notice: same object same ID, same object

00:27:50.120 --> 00:27:56.990
same ID. We have put the same reference into
the array 3 times and that's why we're having

00:27:56.990 --> 00:28:02.970
trouble getting back to our data. So we actually
now have found the problem and it's a serious

00:28:02.970 --> 00:28:08.010
problem. Let's go and look at it in terms
of memory diagrams to help you understand

00:28:08.010 --> 00:28:15.010
what the difficulty is here. This is what
happened in our program. Previous searches

00:28:16.040 --> 00:28:22.890
is an array. You see it right here, so this
array is allocated on the heat and what it

00:28:22.890 --> 00:28:28.170
has is ArrayList of references in it. The
size is currently 3, because we've used the

00:28:28.170 --> 00:28:34.600
search 3 times and we have our data array.
Now remember in our search method we did not

00:28:34.600 --> 00:28:40.810
construct a new ArrayList. We just returned
the one that we already had. What this means

00:28:40.810 --> 00:28:46.810
is that the source in our search method, all
3of the references in our heap and data are

00:28:46.810 --> 00:28:53.020
all pointing to that same single ArrayList.
As a result of that once we had removed all

00:28:53.020 --> 00:28:58.360
these elements from the ArrayList down here,
what happens is we've removed everything.

00:28:58.360 --> 00:29:03.540
We still can't backup. So the problem here
is that we're sharing an ArrayList when we

00:29:03.540 --> 00:29:08.950
should not be. What we need to do in order
to be able to back up is to construct new

00:29:08.950 --> 00:29:15.010
ArrayLists. Now problems like this are incredibly
difficult to find. And in fact, if you did

00:29:15.010 --> 00:29:21.440
not have memory diagrams at your disposal
you might have a very difficult time understanding

00:29:21.440 --> 00:29:26.360
what had happened in this program. But in
essence what happened is even though we were

00:29:26.360 --> 00:29:31.000
returning a reference because we didn't create
a new object, all of our ArrayLists are the

00:29:31.000 --> 00:29:37.220
same object and when we remove everything,
it's gone from everything. We created space

00:29:37.220 --> 00:29:42.700
to save the references to the objects but
we've only called an ArrayList constructor

00:29:42.700 --> 00:29:47.160
once. That means there's only one ArrayList
object and what we've done is we've saved

00:29:47.160 --> 00:29:53.380
its reference many times. This is a very typical
mistake to make. If we want to be able to

00:29:53.380 --> 00:29:59.120
go back to a previous search, we're going
to have to save a separate ArrayList object.

00:29:59.120 --> 00:30:03.110
It's going to need to be constructed inside
the search method and that new reference is

00:30:03.110 --> 00:30:07.940
going to be returned. And then this reference
can be saved in the array, so let's go fix

00:30:07.940 --> 00:30:14.940
our search method. So here's search and we're
going to need to construct a new ArrayList

00:30:21.350 --> 00:30:28.350
of string. I'm going to call it results. Now,
I've got a hint for you when you're programming.

00:30:32.010 --> 00:30:38.290
Notice how we returned the parameter and didn't
call a constructor? That is almost always

00:30:38.290 --> 00:30:44.410
a mistake in Java. So when you're returning
an object like this that means that you usually

00:30:44.410 --> 00:30:49.390
are constructing it inside your method. Not
always, in fact there examples in the Java

00:30:49.390 --> 00:30:54.070
API and particularly in the string builder
class if you want to take a look at those.

00:30:54.070 --> 00:31:00.150
But in general, when you return an object
you want to construct it inside the class.

00:31:00.150 --> 00:31:03.810
Now we're going to have to think through our
logic a little bit, because remember we were

00:31:03.810 --> 00:31:08.430
removing things before and now we're going
to be inserting them. So we're going to say

00:31:08.430 --> 00:31:15.430
if line contains the target, then result.add
the index. Whoops, and I guess I called it

00:31:22.470 --> 00:31:29.470
results! And here's the important part-- we
need to return the new thing that's added.

00:31:30.670 --> 00:31:37.280
Oh and it's not index we want to add of course.
We want to add the line, that is we want to

00:31:37.280 --> 00:31:42.130
add the string. Now the other thing we want
to make sure we do is update the documentation

00:31:42.130 --> 00:31:49.130
again. So here is better documentation: a
newly constructed object with only strings

00:31:54.900 --> 00:32:01.370
that contain the target. Okay, so let's see
if our search refinement is working better

00:32:01.370 --> 00:32:08.370
now. So we're going to go Little Women excerpt.txt,
enter the search refinement so we're going

00:32:15.820 --> 00:32:22.820
to do our search for 20 again. Uh oh! Looks
like an infinite loop and I see it already.

00:32:34.930 --> 00:32:41.930
Think about what we did here, because we're
adding now 
we need to treat our index differently. Now

00:32:46.040 --> 00:32:52.020
that's what happens when you don't read code
carefully enough when you're writing it. So

00:32:52.020 --> 00:32:57.070
because we're now adding it to a new array
that means we need to go through the indices

00:32:57.070 --> 00:33:02.560
one at a time. And in fact, we could even
use a fancier loop for this. So let's actually

00:33:02.560 --> 00:33:09.560
do that. Let's use a loop that's a little
less error-prone. For string s: source at

00:33:15.150 --> 00:33:22.150
this point, we don't need to use the index
at all. If s contains target then we do results.add

00:33:30.090 --> 00:33:37.090
of s and at that point we don't need the index.
I see that I erased one too many curly braces

00:33:42.000 --> 00:33:46.930
and we can just return results. Incidentally,
in this particular case, all those curly braces

00:33:46.930 --> 00:33:50.920
are unnecessary I'm going to leave them there
because as I've mentioned before I think it's

00:33:50.920 --> 00:33:55.850
better practice to have more curly braces.
But in this case you'll notice we've made

00:33:55.850 --> 00:34:01.340
this only three lines of code long, so this
for each loop really works out nicely when

00:34:01.340 --> 00:34:08.340
you're using it with ArrayLists. Okay, so
let's try our code again. So we're going to

00:34:16.040 --> 00:34:23.040
enter our search refinement. We want to continue
and we're going to search for 2. We want to

00:34:24.700 --> 00:34:30.179
continue, then we're going to search for computer
which gives us no results. We want to continue.

00:34:30.179 --> 00:34:37.060
Now if we go back, we're expecting to see
22, which looks good. So let's continue and

00:34:37.060 --> 00:34:44.060
go back again. And notice there's our previous
search and go back again and there are all

00:34:45.190 --> 00:34:52.190
of our chapter headings. So it looks to me
like our backing up is working just fine now.

00:34:52.889 --> 00:34:57.180
So we've test our refining search, of course
as always, we could do more testing than what

00:34:57.180 --> 00:35:02.880
we've done. Let's take a look at what the
memory diagram looks like now. Now I know

00:35:02.880 --> 00:35:07.080
this looks like a lot of detail and it can
be a little bit overwhelming, but take a look

00:35:07.080 --> 00:35:14.080
at what we've done. Previous searches points
to the array right up here and now that array

00:35:15.150 --> 00:35:21.100
has two different ArrayLists. Now these ArrayLists
are sharing strings and that's something we

00:35:21.100 --> 00:35:25.290
might want to think about whether that's a
good thing or a bad thing. So for example

00:35:25.290 --> 00:35:29.830
this refined search, the one that's on the
right, has 2 of the strings that were in the

00:35:29.830 --> 00:35:35.160
original search and that search is now the
one that's pointed to by data. So what we're

00:35:35.160 --> 00:35:42.160
doing now is we have separate ArrayList objects.
That's what that constructor call really meant.

00:35:43.230 --> 00:35:47.540
Here's some questions you might be thinking
about. Why is it okay to have multiple references

00:35:47.540 --> 00:35:53.720
to the string objects, but not to the ArrayList?
Well, the thing is with the ArrayList by having

00:35:53.720 --> 00:36:00.340
one reference to it when we made changes,
all those changes would be reflected. That's

00:36:00.340 --> 00:36:05.400
because ArrayLists are mutable: that is, they
can be changed. On the other hand string objects

00:36:05.400 --> 00:36:10.020
are immutable, so we know that none of those
string objects are going to be changed. And

00:36:10.020 --> 00:36:14.480
that's why sharing is okay and in fact this
is why the Java collections framework was

00:36:14.480 --> 00:36:21.480
designed to use immutable objects. Now another
question you might ask is are we using too

00:36:21.660 --> 00:36:28.260
much memory? And the answer there is really
no. I'm going to go back to the previous slide.

00:36:28.260 --> 00:36:34.810
Notice for example that the only memory we're
using is just for these additional ArrayList

00:36:34.810 --> 00:36:39.700
objects. We're not repeating strings. Remember
that while I'm showing little tiny things

00:36:39.700 --> 00:36:44.860
in the strings here, the strings could be
quite long. And so those are not being repeated.

00:36:44.860 --> 00:36:49.090
There's only one copy of each one of those.
These are the things you can do because string

00:36:49.090 --> 00:36:55.510
is immutable. These ArrayList objects, they're
relatively small, and so that's really not

00:36:55.510 --> 00:37:00.090
so much of a problem and of course the heap
is just references. So remember references

00:37:00.090 --> 00:37:04.790
are tiny, so there's really no problem here
with memory usage. What you've probably noticed

00:37:04.790 --> 00:37:09.420
here is that memory diagrams are our lifeline.
We've really reached the point where we have

00:37:09.420 --> 00:37:14.850
to deeply understand objects and references
to debug these program successfully. This

00:37:14.850 --> 00:37:20.320
is a skill that takes substantial time to
develop. So these memory diagrams are a very

00:37:20.320 --> 00:37:25.410
important technique, but I did demonstrate
some other techniques too. The first thing

00:37:25.410 --> 00:37:30.140
you'll notice that I did was read the code
thoughtfully. That has been proven to be the

00:37:30.140 --> 00:37:35.350
best way to debug programs, believe it or
not. Sometimes people get so involved in the

00:37:35.350 --> 00:37:40.230
debugger and things like that, that they forget
that carefully strategically reading code

00:37:40.230 --> 00:37:46.390
is what's important. Tracing code, seeing
what's in each variable at each time, I didn't

00:37:46.390 --> 00:37:50.860
demonstrate at this time but we've done it
in other programs is another good technique.

00:37:50.860 --> 00:37:55.420
And of course, learning to use the debugger.
So in this case the debugger gave us the answer

00:37:55.420 --> 00:38:00.990
very quickly, because we saw that all of our
objects had exactly the same reference that

00:38:00.990 --> 00:38:05.670
is that when we removed all the strings from
one object we removed them from all the objects

00:38:05.670 --> 00:38:12.320
because we were only sharing one object. So
these are skills you need to continue to develop.

00:38:12.320 --> 00:38:16.270
Now the last thing I want to talk about is
using an array in this. There actually is

00:38:16.270 --> 00:38:21.980
a problem with this program and that's that
you do not usually create arrays of object

00:38:21.980 --> 00:38:27.150
types that have generics. In fact Java doesn't
like that, and if you read much on the Internet

00:38:27.150 --> 00:38:32.660
you'll see a lot of people disapprove of what
we've done here. So it's very important to

00:38:32.660 --> 00:38:37.600
note that many Java programmers are only going
to create arrays of primitive data types.

00:38:37.600 --> 00:38:42.830
I would like to point out though, that the
API does create arrays of objects, particularly

00:38:42.830 --> 00:38:47.900
a method like split in the string class creates
an array of objects. We've used that before;

00:38:47.900 --> 00:38:52.580
it creates an array of strings. Now in all
fairness string is very much like a primitive

00:38:52.580 --> 00:38:57.820
data type because it's immutable, but I do
want you to realize that arrays of objects

00:38:57.820 --> 00:39:04.480
are created even in the API. So it's not completely
out of bounds. I will say though that creating

00:39:04.480 --> 00:39:10.840
arrays of objects that use a generic is very
unusual. A commercial Java programmer probably

00:39:10.840 --> 00:39:15.120
would have used an ArrayList instead of an
array in this program, and that's a modification

00:39:15.120 --> 00:39:20.370
that you might consider doing too. So keep
programming!

