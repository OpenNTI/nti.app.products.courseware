WEBVTT
Kind: captions
Language: en

00:00:00.680 --> 00:00:06.749
&gt;&gt;Let's continue our study of access control
by looking at a set tutor. Here's the problem

00:00:06.749 --> 00:00:11.930
statement: write an interactive tutor to help
students learn set operations. The operations

00:00:11.930 --> 00:00:18.370
that we're going to use are union, intersection,
set difference, element of, and complement.

00:00:18.370 --> 00:00:24.210
Don't worry if you don't know what these operations
are, I'll explained them. So first let's introduce

00:00:24.210 --> 00:00:29.289
sets. So sets contain elements from something
called a universal set in other words the

00:00:29.289 --> 00:00:35.030
set of all possibilities. So this could be
written for example in our case, a set containing

00:00:35.030 --> 00:00:42.030
0, 1, 2 and so on up to 10 for this tutor.
They're denoted by curly braces separated

00:00:42.329 --> 00:00:49.329
by commas. So notice curly brace 1, 3, 5 curly
brace. The order of the elements in a set

00:00:50.200 --> 00:00:56.360
is not important, so the set containing 1,
3 and 5 is the same set as the one containing

00:00:56.360 --> 00:01:03.360
5, 3, and 1. The set elements are not repeated.
So for example the set containing 5, 5 and

00:01:04.269 --> 00:01:09.790
5 is the same set as a set containing 5 and
5 and it's the same set as the set containing

00:01:09.790 --> 00:01:16.500
5 alone. The first set operation is union;
this is all the elements that are in one or

00:01:16.500 --> 00:01:23.500
both sets. So if we take the union of the
set containing 1, 3, and 5 and 1, 4 and 6

00:01:24.060 --> 00:01:30.500
we get a set containing 1, 3, 4, 5, 6. Notice
that I didn't repeat the number 1 even though

00:01:30.500 --> 00:01:35.210
it's in both sets. I could have repeated it
and it would've made any difference but it's

00:01:35.210 --> 00:01:40.680
a little more clean to not repeat it. The
intersection is the elements that are in both

00:01:40.680 --> 00:01:47.420
sets, so if we intersect the set containing
1, 3, 5 and the set containing 1, 4, 6 we

00:01:47.420 --> 00:01:53.700
get the set containing 1. With a set difference
operator the elements in the second set are

00:01:53.700 --> 00:01:59.869
removed from the first set. So if we take
the set difference of 1, 3, 5 and 1, 4, 6

00:01:59.869 --> 00:02:05.090
we get 3 and 5 because those are the elements
in the first set that are not in the second

00:02:05.090 --> 00:02:11.510
set. So notice the set difference operator
is not symmetric, whereas union and intersection

00:02:11.510 --> 00:02:17.049
are. There's a special set you need to know
about it's called the empty set. It's a set

00:02:17.049 --> 00:02:22.249
that doesn't contain any elements. It sort
of equivalent to 0 in mathematics. Now you

00:02:22.249 --> 00:02:27.779
may not know this, but in the history of mathematics
0 was invented centuries later than counting

00:02:27.779 --> 00:02:33.499
numbers. That's sort of counterintuitive for
people who grew up knowing about 0, but actually

00:02:33.499 --> 00:02:38.260
the need to not count anything is something
that was realized a lot later than the need

00:02:38.260 --> 00:02:45.260
to count things. So for example if we take
the set difference of 1, 3, 5 and 1, 2, 3,

00:02:46.659 --> 00:02:52.909
4, 5 it gives us the empty set. The complement
are the operations that are in the universal

00:02:52.909 --> 00:02:59.909
set that are not in the given set. So the
complement of 1, 3, 5, is 0, 2, 4, 6, 7, 8,

00:03:01.139 --> 00:03:07.549
9, 10, all the other elements. There's also
another operator that's called element of

00:03:07.549 --> 00:03:14.549
3 is an element of 1, 3, 5 but 3 is not an
element of 1, 4, 6 so we can see that element

00:03:14.969 --> 00:03:20.919
of is a Boolean operator. So we'll get lots
of practice on these operations if we're testing

00:03:20.919 --> 00:03:26.529
if you haven't seen them before. First let's
design some test data. Now because the data

00:03:26.529 --> 00:03:32.229
is randomly generated we need to be sure that
our tests are exhaustive. We need to be sure

00:03:32.229 --> 00:03:38.299
that every operation is tested several times,
not just once. We also need to make sure that

00:03:38.299 --> 00:03:43.049
empty sets and universal sets are working
properly. These were our boundary condition

00:03:43.049 --> 00:03:47.999
so we know that they can be problems. And
we need to make sure that when users enter

00:03:47.999 --> 00:03:53.650
repeated data that the data is processed properly,
because it is legal to have repeated data

00:03:53.650 --> 00:03:58.609
in the set. We have to make sure that things
are working correctly in that case. So those

00:03:58.609 --> 00:04:04.359
are good boundary conditions. The next thing
we need to do is design our set class in UML.

00:04:04.359 --> 00:04:08.999
For instance data we could use an ArrayList
or an array, either would be fine but I've

00:04:08.999 --> 00:04:15.139
picked an ArrayList. For our class data we're
going to have a limit of 10. Now this is class

00:04:15.139 --> 00:04:19.639
data instead of instance data because it's
going to be a constant. You can tell that

00:04:19.639 --> 00:04:25.500
I'm thinking of it is a constant because I've
used all caps. We also need some constructors.

00:04:25.500 --> 00:04:30.150
We need something called a copy constructor
that creates a copy of sets. You'll see why

00:04:30.150 --> 00:04:34.560
we need that in a few minutes. And you'll
also need to be able to construct an empty

00:04:34.560 --> 00:04:41.560
set. Now here are the signatures for the five
operations. Remember that these are instance

00:04:41.930 --> 00:04:46.500
methods, and instant methods have an implicit
object. Now we could have written these as

00:04:46.500 --> 00:04:51.620
class methods if we wanted to. That would
be a different set class and in fact we could've

00:04:51.620 --> 00:04:56.939
put both the instance methods and the class
methods in a single class. So this is what

00:04:56.939 --> 00:05:02.229
the signature would look like for instance
methods. For union, for example, notice we

00:05:02.229 --> 00:05:08.270
have only one set parameter the other set
parameter is the implicit object and it's

00:05:08.270 --> 00:05:14.009
going to return a set. So the union operation
is not going to change the implicit object.

00:05:14.009 --> 00:05:18.310
Again this could've been done differently
and it's extremely important that we document

00:05:18.310 --> 00:05:24.090
it correctly in the code so people know what
we were doing. Similarly, the intersection

00:05:24.090 --> 00:05:29.659
method takes two sets one the implicit set
and the other the parameter source and returns

00:05:29.659 --> 00:05:36.659
the set. Set difference also takes two sets.
The implicit set be the one that's being subtracted

00:05:36.800 --> 00:05:43.800
from and source will be the one that's subtracted,
and it returns a set too. The element of operator

00:05:44.530 --> 00:05:49.370
takes an integer parameter. Now we could have
made this an int parameter too, but because

00:05:49.370 --> 00:05:54.759
we're storing integer objects using an integer
makes more sense. It returns a Boolean as

00:05:54.759 --> 00:06:00.159
we mentioned before. The complement operator
doesn't have any arguments. That's because

00:06:00.159 --> 00:06:05.979
it's going to take the complement of the implicit
set and it will return a set. We also need

00:06:05.979 --> 00:06:10.389
to consider our Java idioms. We'll need a
two string method that's going to create a

00:06:10.389 --> 00:06:14.969
string, so that's how we'll do output from
the set. Notice that we're not putting in

00:06:14.969 --> 00:06:19.689
anything that prints to the commandline because
those things tend to be very specific to a

00:06:19.689 --> 00:06:24.550
particular program. We don't want to use those
when we're trying to create reusable sets.

00:06:24.550 --> 00:06:29.409
We'll need an equals method that compares
two sets. Now remember we're going to have

00:06:29.409 --> 00:06:33.389
to be careful in this equals method, because
there's no guarantee that the set elements

00:06:33.389 --> 00:06:38.620
are in the same order. What's more we have
to be careful for repeated elements. Now our

00:06:38.620 --> 00:06:42.409
sets aren't supposed to have repeated elements
when we store them, so they'll be a lot to

00:06:42.409 --> 00:06:47.030
think about. Another thing we might want to
consider is what will happen if source is

00:06:47.030 --> 00:06:52.919
null. Null is different than an empty set.
Remember null means that the object wasn't

00:06:52.919 --> 00:06:57.409
constructed, so when you construct an object
and don't put any elements in it that's when

00:06:57.409 --> 00:07:02.330
you get an empty set, but when you don't construct
an object that's when you get a null source.

00:07:02.330 --> 00:07:08.439
These are two separate cases that we're going
to have to consider. If we consider a method

00:07:08.439 --> 00:07:13.749
called parse that will take a string and create
a set object, we might want to consider what

00:07:13.749 --> 00:07:18.560
its signature should look like. So certainly
the parameter is going to be a source, but

00:07:18.560 --> 00:07:24.810
should it be static or not? Should it be void?
Should it return a set? Any one of these is

00:07:24.810 --> 00:07:30.279
possible. For example, we could make it similar
to the parse int method in the integer class.

00:07:30.279 --> 00:07:35.389
In that case it would be static and it would
return a set. We could also make it an instance

00:07:35.389 --> 00:07:42.259
method. If it's an instance method it's going
to return void and not be static. Either one

00:07:42.259 --> 00:07:46.879
of those choices would be possible. I'm going
to make it an instance method today, but we'll

00:07:46.879 --> 00:07:51.129
talk about whether that was a good design
decision later. The next thing we need to

00:07:51.129 --> 00:07:56.240
be able to do is to create random sets. Now
this could be a class method. For example,

00:07:56.240 --> 00:08:01.969
public static set make random set would be
one possibility. It also could be an instance

00:08:01.969 --> 00:08:08.379
method. So that would look like public void
create random set. Notice here the implicit

00:08:08.379 --> 00:08:13.979
object is the one that will be initialized.
We also need to have create random element.

00:08:13.979 --> 00:08:20.059
That will be a class method because it doesn't
require a set object of any type. Now we have

00:08:20.059 --> 00:08:24.990
a critical design decision to make: should
we store repeated elements or not? This is

00:08:24.990 --> 00:08:29.409
a critical design decision. This is something
where if you make the wrong decision, you're

00:08:29.409 --> 00:08:34.419
going to make your job enormously harder than
it has to be. So we want to make sure we make

00:08:34.419 --> 00:08:39.199
the decision that keeps the logic as simple
as possible. Well repeated elements make the

00:08:39.199 --> 00:08:43.800
logic much more complicated. We're going to
definitely not want to store them. This also

00:08:43.800 --> 00:08:48.310
has the benefit of keeping the ArrayList a
little smaller, because our sets are so tiny

00:08:48.310 --> 00:08:52.930
that isn't really a very important design
criterion. The main criterion is keeping the

00:08:52.930 --> 00:08:58.709
logic simple. This is going to require constant
thought when we're developing methods. If

00:08:58.709 --> 00:09:03.560
we put even one duplicate element in to a
place where we weren't expecting it, none

00:09:03.560 --> 00:09:07.660
of our methods are going to work. So we're
going to have to think about this all the

00:09:07.660 --> 00:09:12.699
time. To make this easier I'm going to create
a method called private void remove duplicates,

00:09:12.699 --> 00:09:17.329
and its job is going to be to check through
a set and make sure there are no duplicate

00:09:17.329 --> 00:09:22.490
elements. If we call that at the end of other
methods, assuming it's running correctly,

00:09:22.490 --> 00:09:27.459
then we know that we won't have any duplicate
elements. Now notice this is a private method.

00:09:27.459 --> 00:09:32.209
This is not something we want people outside
of the class to be aware of. In fact, if you'll

00:09:32.209 --> 00:09:36.570
notice, people outside of the class don't
have any idea that we're using an ArrayList

00:09:36.570 --> 00:09:42.060
to store this data. We'll talk more about
this design decision later. Now it's time

00:09:42.060 --> 00:09:48.089
to implement some of our set. So we'll implement
the default constructor, the equals operator,

00:09:48.089 --> 00:09:53.070
the two string method, the intersection, and
remove duplicates. So that will give us a

00:09:53.070 --> 00:10:00.070
nice cross-section of methods to look at.
Here we go to Eclipse. So here's our set class.

00:10:03.300 --> 00:10:08.000
Now our universal set goes from zero to limit.
One thing I see about the documentation I

00:10:08.000 --> 00:10:15.000
wrote is that I wasn't specific about it being
inclusive. That was a mistake. We definitely

00:10:15.790 --> 00:10:21.180
want to fix that. So here we have class data
that's the limit, now the reason the limit

00:10:21.180 --> 00:10:25.540
is class data is because it's a constant.
When we have a constant remember there is

00:10:25.540 --> 00:10:31.610
no reason that each object needs to have its
own copy, because constants can't be changed.

00:10:31.610 --> 00:10:38.560
So one copy can be shared through all of the
elements. Whatever instance does need to have

00:10:38.560 --> 00:10:45.490
is an ArrayList of integer called elements.
So that's our instance data. Now the first

00:10:45.490 --> 00:10:51.500
thing we were going to do is construct an
empty set. Notice that the goal of all constructors

00:10:51.500 --> 00:10:56.810
is to make sure that the instance data is
properly initialized. Well our only instance

00:10:56.810 --> 00:11:03.810
data is elements, the ArrayList, so let's
initialize that. So there we go. One of the

00:11:10.100 --> 00:11:15.380
things that I do when I'm building constructors
is methodically look over every single piece

00:11:15.380 --> 00:11:19.790
of instance data and make sure that everything
is set up correctly. Now it's not very hard

00:11:19.790 --> 00:11:23.970
in this case because we have only one piece
of instance data, but in general that's a

00:11:23.970 --> 00:11:30.970
good rule. Now this is another constructor
that I created for you and here we have a

00:11:32.339 --> 00:11:35.930
copy constructor. Let's look at that one in
a minute, because that's one you don't see

00:11:35.930 --> 00:11:41.050
as often. So what you're doing here is it's
a constructor, you can see it's a constructor

00:11:41.050 --> 00:11:44.930
because it doesn't have a return type and
because it starts with the name of the class

00:11:44.930 --> 00:11:51.149
set. What makes this one different is it's
copying a set. Now what we need to be careful

00:11:51.149 --> 00:11:56.550
of here is to make sure that we actually copy
the data in old set. What we don't want to

00:11:56.550 --> 00:12:03.550
do is say elements equals old set.elements.
Let me write that code for you to look at.

00:12:09.410 --> 00:12:16.410
[typing] So that is wrong, wrong, wrong. The
problem here, aside from the missing elements

00:12:22.029 --> 00:12:26.579
is the fact that what you're doing is sharing
a reference between those two sets, which

00:12:26.579 --> 00:12:31.069
means that if you change the elements in old
set the elements in the set you're constructing

00:12:31.069 --> 00:12:37.170
will change too. That is the kind of error
that's incredibly hard to find in code, particularly

00:12:37.170 --> 00:12:43.029
since people often forget to look at constructors
as possible sources of bugs. So what we needed

00:12:43.029 --> 00:12:49.009
to do was to create a new set of elements
from the old set. Now there is a method in

00:12:49.009 --> 00:12:55.019
the ArrayList class called add all that makes
it possible to copy the elements over in one

00:12:55.019 --> 00:13:02.019
step. You also could have done this with a
for loop if you prefer to do it yourself.

00:13:02.139 --> 00:13:07.220
Here's our remove duplicates method. So we
need to think how we're going to do that.

00:13:07.220 --> 00:13:11.970
We need to step through the elements one at
a time and make sure that they don't match

00:13:11.970 --> 00:13:16.779
any other element. If you think about it,
you could draw it sort of like a triangle,

00:13:16.779 --> 00:13:21.620
where the first element steps through all
of the other elements the second element steps

00:13:21.620 --> 00:13:26.480
through the ones that are further on, the
third, and so on. When you have that kind

00:13:26.480 --> 00:13:31.339
of organization it is a nested for loop, so
that's what we're expecting. Well actually

00:13:31.339 --> 00:13:35.310
is just a nested loop. The fact that I'm going
to do it as a for loop is just a personal

00:13:35.310 --> 00:13:42.310
preference. So for int item is zero item less
than elements.size, remember this is an ArrayList

00:13:48.589 --> 00:13:54.420
so we're using ArrayList methods, plus plus
item. So what we're going to do inside this

00:13:54.420 --> 00:14:01.420
loop now make sure that this item is not equivalent
to the other items. So that's another for

00:14:07.250 --> 00:14:14.250
loop. So I'm going to call this test and it's
going to start at item +1. We don't need to

00:14:16.089 --> 00:14:21.089
start at 0, because we know we already checked
the items that are before this one. So now

00:14:21.089 --> 00:14:28.089
items going to be less than element.size,
whoops! Not item, that's test. Plus plus test.

00:14:35.440 --> 00:14:40.129
Now one thing you might notice here is I didn't
call my indices i and j. I did that for a

00:14:40.129 --> 00:14:44.819
particular reason. When I was programming,
the worst programming mistake I ever made

00:14:44.819 --> 00:14:50.129
in my life, one that cost me six weeks of
time was made when I was doing my doctoral

00:14:50.129 --> 00:14:56.560
dissertation. I actually reversed an m and
an n an as indices in code and couldn't find

00:14:56.560 --> 00:15:02.319
it forever. Now as a result, I don't tend
to use a lot of single letter variable names.

00:15:02.319 --> 00:15:07.240
Okay, so now we have two for loops. We need
to compare the elements and see if they're

00:15:07.240 --> 00:15:14.240
equal. So if elements of get and an item is
equal to elements.get at test. So that means

00:15:23.420 --> 00:15:30.420
we found a duplicate. So in that case we need
to remove the item-- looks like I've forgotten

00:15:37.470 --> 00:15:43.199
my s in elements again. So now we need to
think very strategically about how we're going

00:15:43.199 --> 00:15:47.379
to do that, because when we remove an item
remember we're going to change the size of

00:15:47.379 --> 00:15:53.250
elements and that's going to mess up the loop.
So if we remove the first one then we got

00:15:53.250 --> 00:16:00.250
a problem, so we definitely need to remove
the second one so we'll do elements.delete

00:16:01.519 --> 00:16:08.519
of test. Now for some reason it's not liking
delete. So let's go to the API and see what

00:16:10.540 --> 00:16:17.540
the method is really called in the ArrayList.
So here's our ArrayList class. It's probably

00:16:27.629 --> 00:16:32.050
called remove, but it never hurts to look
these things up. Remember that there's not

00:16:32.050 --> 00:16:37.870
a lot of value in memorizing these methods
when the API is so convenient. Ah yes, and

00:16:37.870 --> 00:16:44.870
we can see that the method is actually called
remove. Now we have to think carefully about

00:16:51.740 --> 00:16:56.220
what we're going to do with the index. The
problem is that remember when we remove an

00:16:56.220 --> 00:17:02.230
item from an ArrayList, the rest of the items
shift over to the same spot. So we need to

00:17:02.230 --> 00:17:08.350
make sure that when our list starts up it's
checking that first item. In other words,

00:17:08.350 --> 00:17:15.350
we're going to have to reset our counter test.
So test needs to be reset to item +1. Now

00:17:16.960 --> 00:17:21.770
let's think about that for a minute. When
we get to the end of the loop, test is going

00:17:21.770 --> 00:17:28.290
to be incremented because that's how for loops
work. So if we put item +1 in here, at the

00:17:28.290 --> 00:17:32.590
end of the loop that will be incremented to
item +2 and that means we're going to skip

00:17:32.590 --> 00:17:39.590
an element. So it really needs to be initialized
to item. So let's clean up the code and document

00:17:47.400 --> 00:17:54.400
it a little bit. The method has a void return
type and so there's nothing else we need to

00:17:57.180 --> 00:18:02.640
do here. Now one thing we might want to do
at this point is test a little bit. Now I

00:18:02.640 --> 00:18:06.620
don't want to use the full tutor because I
haven't talked about how that's designed yet.

00:18:06.620 --> 00:18:11.670
So we could create just a little dummy test
to experiment with it and see how things are

00:18:11.670 --> 00:18:16.690
going. The only problem with that is that
we haven't written our to string method first,

00:18:16.690 --> 00:18:21.000
so strategically it probably would have been
wise to write to string before we wrote some

00:18:21.000 --> 00:18:28.000
of these other methods. So let's go and do
that one next. We're scrolling past some of

00:18:32.280 --> 00:18:39.280
the other elements that I've already written
for you. Of course one way that we could have

00:18:41.310 --> 00:18:48.310
gotten to this a little more quickly is to
take advantage of Eclipse. We're way down

00:18:51.910 --> 00:18:58.910
here in the set tutor, so let's open that
up and open the source code, and the default

00:19:00.500 --> 00:19:07.500
package, and the set class. Remember that
it has lots and lots of methods. One of the

00:19:11.000 --> 00:19:15.400
things that you can notice is that Eclipse
is actually documenting some of the elements

00:19:15.400 --> 00:19:21.740
of Java for you. For example this s that stands
for static and that really helps on limit

00:19:21.740 --> 00:19:27.450
notice we have static and we also have a capital
f which stands for final. Elements was our

00:19:27.450 --> 00:19:33.410
instance data and it gets a little red box.
The solid red box stands for a private method.

00:19:33.410 --> 00:19:38.680
So these c's here that stands for constructor
so notice that Eclipse is giving you a lot

00:19:38.680 --> 00:19:43.660
of help. One of the ways that you can use
this in programming is to make sure that things

00:19:43.660 --> 00:19:50.560
are what you think they are. Let's say for
example we had made one of these sets, made

00:19:50.560 --> 00:19:56.830
one of the classic programming mistakes of
putting a return type. Did you see what happened

00:19:56.830 --> 00:20:02.340
in Eclipse? It moved this constructor now
and is showing that as an instance method.

00:20:02.340 --> 00:20:07.960
Well the reason it's seeing it as an instance
method is because we have a return type here.

00:20:07.960 --> 00:20:12.370
So actually Eclipse can help you find some
of the really hard mistakes that you can make

00:20:12.370 --> 00:20:18.580
in programming. From this view, we can click
on the to string method and Eclipse will take

00:20:18.580 --> 00:20:25.580
us there quickly. What we need to do here
is to return a representation of a set. Because

00:20:27.060 --> 00:20:31.710
this is the only way we have of out putting
the elements in the set, we need to make sure

00:20:31.710 --> 00:20:36.560
that we do it in a way that's attractive so
I'm going to do it with curly braces and commas,

00:20:36.560 --> 00:20:40.440
and we need to make sure that it really looks
nice because we don't want other people to

00:20:40.440 --> 00:20:45.520
have the clean up our work. So first I'm going
to create a string builder. The reason I'm

00:20:45.520 --> 00:20:49.380
making a string builder instead of a string
is because we're going to be building this

00:20:49.380 --> 00:20:54.440
up a piece at a time I could do this with
concatenation using the plus operator, but

00:20:54.440 --> 00:20:59.670
this is just a little nicer way to do it.
So here we have an empty string builder. The

00:20:59.670 --> 00:21:06.670
first thing we want to do is to append our
first curly brace. And of course it helps

00:21:13.570 --> 00:21:20.400
if you spell the method name correctly, and
use the right number of parentheses. So now

00:21:20.400 --> 00:21:26.890
this has a curly brace in it. So we need to
put the elements in and the commas. So that's

00:21:26.890 --> 00:21:33.890
going to be a loop. So the index is going
to be less than the elements.size. And of

00:21:39.700 --> 00:21:46.700
course we'll increment it. So now we'll do
result.append elements.get of index. The comma

00:21:52.740 --> 00:21:56.690
is a little bit different though. We have
to be careful not to put a comma after the

00:21:56.690 --> 00:22:01.480
last element, because that doesn't look right.
That isn't how sets are done. So we need to

00:22:01.480 --> 00:22:08.480
check and see if we're at the last element.
So if index equals elements.size -1 well,

00:22:12.310 --> 00:22:17.680
at that point, we will do...oh! I was going
to put the comment in here, but the logic

00:22:17.680 --> 00:22:23.350
is actually reversed. We want to put the comma
in when it's not equal, not when it's equal

00:22:23.350 --> 00:22:30.350
to. So when it's not the last element we'll
do result.append, elements. whoops! Not elements--

00:22:32.780 --> 00:22:39.780
a comma. Now I made this one a string when
I made the other one a character. Doesn't

00:22:41.730 --> 00:22:48.730
really matter so much, but let's be consistent.
We're always striving to have our code be

00:22:49.880 --> 00:22:55.580
as beautiful as possible. So as long as we're
not at the last element we put in a comma

00:22:55.580 --> 00:23:02.580
and at the end we do result.append. Our second
curly brace so there we go. Now remember that

00:23:13.500 --> 00:23:20.500
our return type is string, not string builder.
So we need to return not result but result.to

00:23:20.610 --> 00:23:27.610
string. Now we haven't documented this much,
so let's actually add some documentation before

00:23:28.390 --> 00:23:35.390
we move on. So we're going to add the elements
to the string builder one at a time, and this

00:23:39.260 --> 00:23:46.260
one definitely needs some documentation: don't
put a comma after the last element. Well thankfully

00:23:48.290 --> 00:23:51.930
we're not at a position where we actually
could test this class a little. It's always

00:23:51.930 --> 00:23:56.790
a good idea to create these little dummy classes
that allow you to test things. So I'm just

00:23:56.790 --> 00:24:03.790
going to call this dummy test, put a main
program in it and exercise our sets a little

00:24:04.010 --> 00:24:11.010
bit. So we'll construct a set. So that's our
default constructor. Now we need to find a

00:24:19.470 --> 00:24:25.260
way to put elements in a set, so we need to
take a look at some of our possibilities here.

00:24:25.260 --> 00:24:31.260
Remember we had a parse method that read input
from the keyboard? That's a good one to use.

00:24:31.260 --> 00:24:38.260
So we'll have set one.parse. Now in this case
we aren't going to actually read in the keyboard

00:24:38.700 --> 00:24:45.700
we're just going to put in a set. And then
we'll do system out print line set one. Notice

00:24:55.140 --> 00:24:59.450
we don't have to actually call to string,
because it's called automatically by the print

00:24:59.450 --> 00:25:04.510
line statement. So this would give us an idea
of whether our constructor whether our to

00:25:04.510 --> 00:25:08.830
string method are working correctly. Now it
isn't going to tell us anything about our

00:25:08.830 --> 00:25:13.400
remove duplicates method, because we haven't
actually called that method. So we'll have

00:25:13.400 --> 00:25:18.820
to do some more testing in a minute but let's
just run this for now. So this is my test

00:25:18.820 --> 00:25:23.960
early, test often strategy. So our set's looking
pretty good. We might think about whether

00:25:23.960 --> 00:25:28.710
we wanted some extra spaces in there just
to spread this out a little bit. It would

00:25:28.710 --> 00:25:34.460
be okay either way. Maybe it looks fine just
as it is. So let's now check our remove duplicates

00:25:34.460 --> 00:25:41.100
method. Now the remove duplicates method was
called by the parse method, because anytime

00:25:41.100 --> 00:25:45.780
you're reading things from a user you can't
trust them to follow the rules. Besides, it's

00:25:45.780 --> 00:25:49.860
actually legal to have multiple elements in
a set. We just don't want to store our data

00:25:49.860 --> 00:25:55.380
that way. So this is the kind of data, in
fact, let's even make the test a little bit

00:25:55.380 --> 00:26:02.380
harder. Okay so we know what we want here
we want a set that contains just 1, 3, 5 so

00:26:03.740 --> 00:26:10.740
let's see if that's working--1, 3, 5 looks
like our parse method is working well and

00:26:11.980 --> 00:26:16.850
it also looks like removing duplicates is
working. So we did a good job on that method.

00:26:16.850 --> 00:26:23.850
That's actually a tricky method to implement.
So let's go back to our set class and find

00:26:24.230 --> 00:26:31.230
our other methods. We were going to implement
an intercession method 
which is right here. Now the intersection

00:26:37.050 --> 00:26:44.050
method is returning a set, so we need to create
that set. So I'm calling a constructor. At

00:26:47.110 --> 00:26:53.600
the end we're going to return it by putting
that in now, we'll get Eclipse to stop freaking

00:26:53.600 --> 00:26:59.070
out and putting things underlined in red.
So now we need to think through the strategy

00:26:59.070 --> 00:27:04.420
here. We need to step through both of these
sets and see if the elements are the same.

00:27:04.420 --> 00:27:09.210
So if we have any elements that are identical,
we need to make sure that they get included

00:27:09.210 --> 00:27:16.210
in the intersection. So we have a nested for
loop again. So I'm going to say: implicit

00:27:20.660 --> 00:27:27.660
is 0 and implicit is less than elements.size
plus plus implicit. Now the reason I'm calling

00:27:33.940 --> 00:27:39.270
it implicit is because this is the index for
the implicit set. Remember that because this

00:27:39.270 --> 00:27:44.100
is an instance method, that means there's
a set that's hidden around in the background.

00:27:44.100 --> 00:27:51.100
It's called this. Now some people find it
easier to actually say this.elements.size,

00:27:51.700 --> 00:27:56.500
and that's perfectly legal. If you find that
easier I encourage you to do it, because it

00:27:56.500 --> 00:28:01.520
reminds you of which set we're talking about.
Now our nested loop is going to have to step

00:28:01.520 --> 00:28:08.520
through the other set. That's the one that's
called source. So int and I'll call this source

00:28:08.610 --> 00:28:15.610
index, is 0 source index is less than. Now
at first you might think, hey wait a minute.

00:28:19.490 --> 00:28:24.270
Our source method doesn't have any kind of
index method it doesn't tell me how many elements

00:28:24.270 --> 00:28:29.370
so how am I going to be able to work with
this? Well we're inside the source class,

00:28:29.370 --> 00:28:36.370
so we have access to the private data of the
source object. So we can do less than source.elements.size.

00:28:43.130 --> 00:28:46.710
And of course, we'll increment source index.
Now of course you can see I've gone off the

00:28:46.710 --> 00:28:53.710
screen here, so of course we always rewrite
that method so that we can see all the data

00:28:55.940 --> 00:29:02.940
that's on the screen. And let's put some comments
in here so we know which loop we think is

00:29:06.860 --> 00:29:13.860
ending and which curly brace. Okay, so what
we need to do is to compare these two elements.

00:29:18.280 --> 00:29:25.280
So if elements.get of implicit. Now we need
to think about this comparison. Do we want

00:29:27.670 --> 00:29:32.920
to use equals equals or do we want to use.equals?
Well what we're comparing here are integer

00:29:32.920 --> 00:29:39.920
objects not int objects. Integers required.equals.
So this'll be elements.get of source index.

00:29:47.500 --> 00:29:54.500
So when those two are equal to each other
that's when the element goes into the intersection,

00:29:55.490 --> 00:30:02.490
we'll do result.elements.add elements.get
of implicit. Now it looks like Eclipse is

00:30:10.960 --> 00:30:17.960
freaking out over something, so let's see
what it's complaining about. Oh, I see what

00:30:18.600 --> 00:30:25.600
the problem is. I spelled it wrong. That'll
kill you every time. Okay, so now we're ready

00:30:27.660 --> 00:30:33.560
to go forward again. Notice that I did not
jump at what Eclipse was saying immediately

00:30:33.560 --> 00:30:38.030
and remove that and put an equals equals,
I knew I needed an equals method and so I

00:30:38.030 --> 00:30:41.770
wasn't willing to give up on it. Those are
things you need to do is to learn to trust

00:30:41.770 --> 00:30:46.990
your instinct on code. The next thing we need
to consider is whether there's any way we

00:30:46.990 --> 00:30:52.360
could have put duplicate elements in. Because
we're going through each element with every

00:30:52.360 --> 00:30:57.760
other element in the set, assuming that the
sets don't have duplicate elements, we should

00:30:57.760 --> 00:31:04.760
be okay. But on the other hand, it never hurts
to be extremely cautious. We can call our

00:31:07.780 --> 00:31:13.540
little private remove duplicates method. Now
if you think that I'm being excessively cautious,

00:31:13.540 --> 00:31:18.870
absolutely. Remember that when you see a good
computer scientist just like a good statistician,

00:31:18.870 --> 00:31:24.170
they're going to be wearing a belt and suspenders.
We are cautious people. Why not? Now I am

00:31:24.170 --> 00:31:31.170
going to document this should not be necessary
if neither of the sets has duplicate elements,

00:31:37.320 --> 00:31:44.320
but it doesn't hurt to be cautious. Frankly
because the sets we're working with are so

00:31:45.750 --> 00:31:51.150
small here, the expense of calling a method
like remove duplicates is not something we

00:31:51.150 --> 00:31:56.070
really have to worry about. So here we're
getting extra error checking, extra assurance

00:31:56.070 --> 00:32:02.010
that our code will actually work and also
making sure that everything is just perfect.

00:32:02.010 --> 00:32:06.050
So that's a good investment, even if it turns
out that that we don't have any duplicates

00:32:06.050 --> 00:32:13.050
in it. So let's go to our dummy test and try
out our intersection method and see what happens.

00:32:13.260 --> 00:32:20.260
So we're going to need two sets and let's
parse in something for set two. So we want

00:32:25.580 --> 00:32:32.580
something that has an intersection, but we
also want something that isn't going to intersect.

00:32:34.330 --> 00:32:38.710
Of course as always we need to be thinking
to ourselves about what this should give at

00:32:38.710 --> 00:32:45.710
the end. So let's think about that, because
we're intersecting a set that contains 1,

00:32:46.850 --> 00:32:53.040
3, 5 with a set that contains 1, 3, 4, 6,
8, 10, we should get a set that contains 1

00:32:53.040 --> 00:33:00.040
and 3. What we're going to print out here
now is set 1.intersection with set 2. Now

00:33:05.710 --> 00:33:10.500
think about what we're doing here very carefully.
Remember, this intersection method is returning

00:33:10.500 --> 00:33:16.040
a new set and that set is the one that's being
printed out. Let me show you another way to

00:33:16.040 --> 00:33:23.040
write this code, something that may be easier
for some people. So we can actually store

00:33:30.530 --> 00:33:36.230
the result of the intersection method in another
set and then print out set 3. Don't be afraid

00:33:36.230 --> 00:33:41.290
to do things like that. It really help sometimes
if you know exactly what type the variables

00:33:41.290 --> 00:33:48.290
are, so I encourage you to do that. Uh oh!
We've got a problem. So remember, when we

00:33:52.320 --> 00:33:59.320
debug these things we go back to the last
line that we wrote, which is 171 and let's

00:34:00.910 --> 00:34:07.180
see what's going on here. So it's complaining
about not being able to find one of these

00:34:07.180 --> 00:34:12.609
2 methods. So let's check and make sure we've
got the right indices in the loop. So we start

00:34:12.609 --> 00:34:19.609
implicit at 0. We go to less than size and
increment implicit. That looks correct. We

00:34:19.730 --> 00:34:26.329
started source index at 0, go to less than
source.elements.size, and then increment source

00:34:26.329 --> 00:34:33.329
index. So, what could be going wrong here?
Well one thing we can do is we can use our

00:34:36.509 --> 00:34:43.509
debugger to tell us what's going on. So let's
go to debug mode. Now we know the problem

00:34:44.419 --> 00:34:51.159
is right here, so the place we want to stop
is at this line so that we can check things

00:34:51.159 --> 00:34:55.960
out. Now we may want to think about whether
we want to make our example smaller, but let's

00:34:55.960 --> 00:35:02.960
run it as it is right now. So remember when
you run in debug mode you use the little bug.

00:35:07.460 --> 00:35:14.460
And we're going to look at source. So here
is its data. We can see that it has 5 elements,

00:35:32.569 --> 00:35:39.569
so there's 1, there's 3, there's 4, there's
6. So this is our second set. Notice that

00:35:48.440 --> 00:35:55.119
these are null, so these are not the values
we're looking for. So we can see that we're

00:35:55.119 --> 00:36:02.119
getting the right things in there. So that's
that looks perfectly fine. Now the other thing

00:36:05.859 --> 00:36:10.619
we want to look at is in this. So let's go
and look at its elements. And we're expecting

00:36:10.619 --> 00:36:17.619
to see 1, 3, and 5...1, 3, and 5 so those
values look okay. So let's continue a step

00:36:34.759 --> 00:36:41.220
and take a look at what's happening in the
data. So we've got everything displaying.

00:36:41.220 --> 00:36:48.220
So we see that implicit is 1 and source index
ix 0. That looks fine. 2, 3, and then it went

00:36:55.569 --> 00:37:00.289
out of bounds. So we can see what happened
is that we went out of bounds on one of those

00:37:00.289 --> 00:37:06.269
array indices. Okay, so that tells us what's
going on. Let's go back and debug our program

00:37:06.269 --> 00:37:12.950
a little bit now. Now notice that the debugger
has taken us into the ArrayList class. Remember

00:37:12.950 --> 00:37:17.069
that this is not where the problems are in
our code. ArrayList is part of the standard

00:37:17.069 --> 00:37:24.069
Java API. This is not the problem. Let's go
here and take one more look at the code. Okay,

00:37:29.809 --> 00:37:36.809
0 less than size, increment implicit. 0 less
than size increment source index. So notice

00:37:44.089 --> 00:37:48.279
that I've been paying a lot of attention to
those for loops, but not paying so much attention

00:37:48.279 --> 00:37:53.410
to the if statement. That's kind of foolish
because the if statement is where it's breaking.

00:37:53.410 --> 00:38:00.410
Take a look at what I did. Elements.get, elements.get
Well I wasn't supposed to use elements here,

00:38:00.480 --> 00:38:07.319
I was supposed to use source.elements. There
we go. I bet our code's going to run better

00:38:07.319 --> 00:38:14.319
now. Ahh, so we have 1 and 3. So it looks
like our intersection code may be running

00:38:16.589 --> 00:38:23.589
correctly. So the last method we need to write
is equals. So let's go and find that one.

00:38:24.170 --> 00:38:31.170
And here's our equals method. There's some
special cases we have to consider here. First

00:38:32.380 --> 00:38:37.559
off is source is null. Now remember, null
is not the same thing as the empty set. When

00:38:37.559 --> 00:38:42.349
an object is null that means it hasn't been
constructed. So this is an odd case but it's

00:38:42.349 --> 00:38:46.490
one that we usually take care of in equals.
Now there are some technical reasons for this

00:38:46.490 --> 00:38:50.559
that you'll understand a little bit later
in programming, but for right now I just want

00:38:50.559 --> 00:38:55.599
to make sure that I'm modeling the best practice
for you. So if source is null what we do is

00:38:55.599 --> 00:39:02.599
we return false. Now the reason behind that
is because if it's null, it can't be true.

00:39:03.599 --> 00:39:07.960
There's no way that you can call an equals
method on an object. So if the parameter is

00:39:07.960 --> 00:39:14.640
null it definitely can't be the same thing.
Another style thing that I should mention

00:39:14.640 --> 00:39:19.440
while I'm doing this is when we have these
little tests to see if the arguments are legal.

00:39:19.440 --> 00:39:24.670
What I try to do is put them at the top of
the method and return from them. So if the

00:39:24.670 --> 00:39:29.859
test fails, get out of there. This prevents
getting a lot of deeply nested if statements

00:39:29.859 --> 00:39:34.289
that make the code harder to read and harder
to understand. It is little bit tricky at

00:39:34.289 --> 00:39:39.480
first, because if you don't realize that there's
sort of an implied else in this code, you

00:39:39.480 --> 00:39:43.880
might think that I'm still going on it. But
you'll get used to it once you see this convention

00:39:43.880 --> 00:39:50.200
more. The next case we want to consider is
what if the sets had a different number of

00:39:50.200 --> 00:39:54.430
objects? Because if the sets have a different
number of objects, well guess what? The sets

00:39:54.430 --> 00:39:59.769
can't be equal. Now notice this is only true
because we remove duplicates. If we hadn't

00:39:59.769 --> 00:40:03.890
removed duplicates this would not be true
and our task of writing equals would be a

00:40:03.890 --> 00:40:10.890
lot harder. So if this.elements.size is not
equal to source.elements.size, this means

00:40:18.289 --> 00:40:25.289
that the to's have different numbers of objects,
we're going to return false. So if we get

00:40:26.829 --> 00:40:31.630
to this point we know that the sets have the
same number of objects. What we need to do

00:40:31.630 --> 00:40:36.730
now is check and make sure they have the same
objects. So to do that we need to look and

00:40:36.730 --> 00:40:41.779
make sure that every element in set 1 is in
set 2. Now if you're the cautious type you

00:40:41.779 --> 00:40:46.059
might say, well why don't we also check and
make sure that every element in set 2 is in

00:40:46.059 --> 00:40:51.279
set 1? Well when you don't have duplicates,
you have the same number of elements you don't

00:40:51.279 --> 00:40:56.009
have to do both of those checks one of them
will suffice. Of course as you know I'm not

00:40:56.009 --> 00:41:00.589
opposed to doing a little bit of extra checking,
so if it makes you happier to do both of them

00:41:00.589 --> 00:41:07.589
by all means be my guest. So we'll do implicit
is 0, implicit is less than elements.size

00:41:15.230 --> 00:41:22.160
increment implicit. And of course once again
we've gone off the screen a little bit, so

00:41:22.160 --> 00:41:29.160
we're going to pull that back. Now for source
index is zero source index is less than elements.size

00:41:49.839 --> 00:41:56.839
increment source index. So this steps through
both of our elements. So now we need to think

00:41:58.039 --> 00:42:03.249
through the logic. Do we want to do something
when we find objects that match or when we

00:42:03.249 --> 00:42:08.009
don't find objects that match? Well it turns
out if we find an object that's in the first

00:42:08.009 --> 00:42:13.410
set that's not in the second set, we're actually
done. That means that these sets are not equal

00:42:13.410 --> 00:42:20.410
to each other. If elements.get of implicit
is not equal, now we need to think, do want

00:42:24.970 --> 00:42:31.960
to use ! equals to or do we want to use.equals?
This is an integer. So since it's an integer

00:42:31.960 --> 00:42:38.960
we know.equals is what we should use to source.elements.get
of source index. Now our lines of code have

00:42:44.690 --> 00:42:48.950
gotten a little bit long here so we need to
think about where's a good place to break

00:42:48.950 --> 00:42:54.269
it. I think probably the best place is right
there just in terms of being able to see all

00:42:54.269 --> 00:43:01.269
of our code. If they're not equal, if we find
an element that in elements that's not in

00:43:03.670 --> 00:43:10.509
source.elements. We need to think through
this a little bit more carefully. We shouldn't

00:43:10.509 --> 00:43:15.900
be comparing individual elements. We should
be looking to see if the element that's in

00:43:15.900 --> 00:43:21.089
the implicit set is somewhere in the source
set. Well let's think about it. There's a

00:43:21.089 --> 00:43:26.230
method in the ArrayList that does it. It's
called contains. So let's not go and reinvent

00:43:26.230 --> 00:43:33.230
the wheel here. Let's use what's available.
So if elements.contains, sorry source.elements

00:43:41.740 --> 00:43:48.740
contains elements.get of implicit. Well, is
it when it's contained that we want to do

00:43:52.210 --> 00:43:57.630
something or when it's not contained? So if
we find an element in the implicit set that's

00:43:57.630 --> 00:44:04.099
not anywhere in source.elements, notice not,
that's where that exclamation point comes

00:44:04.099 --> 00:44:11.099
from, that's when we're ready to return false.
Now one thing you'll notice is this is still

00:44:13.220 --> 00:44:18.029
a nested loop, it's just the other nested
loop is in the contains method. It was written

00:44:18.029 --> 00:44:23.670
by the people who write the ArrayList. So
let's see what Eclipse is unhappy about. It

00:44:23.670 --> 00:44:30.670
looks like I may have cheated it out of a
parenthesis. There we go. Now if we get all

00:44:31.329 --> 00:44:37.009
the way to the end, source wasn't null. It
had the same number of elements and there's

00:44:37.009 --> 00:44:43.230
nothing in elements that isn't also in source.
Guess what? That means it equals is true.

00:44:43.230 --> 00:44:49.539
So that's where we should return true, and
notice that removes Eclipse's last problem.

00:44:49.539 --> 00:44:56.180
Let's go to our dummy test and test this method
just a little bit. So now we're going to do

00:44:56.180 --> 00:45:03.180
set 1 equals set 2. Now this is not a set
operation, so we're going to need to store

00:45:04.150 --> 00:45:08.670
the result in a Boolean and print out that
result. Now at this point our two sets are

00:45:08.670 --> 00:45:15.670
not equal to each other, so that's definitely
a case we should check. Well that was interesting.

00:45:24.160 --> 00:45:30.059
Let's just run that again. Okay, so I don't
know exactly what Eclipse was thinking right

00:45:30.059 --> 00:45:34.829
there but it's now thinking the right thing.
Let's check a case where they are equal to

00:45:34.829 --> 00:45:41.829
each other, just to make sure we've covered
all the ground. Eclipse is having a bad day.

00:45:49.640 --> 00:45:55.140
So here is true, that looks good. One thing
we might want to try is an empty set. You

00:45:55.140 --> 00:46:02.140
know that's one of those nasty little boundary
conditions that tends to show up. I don't

00:46:06.460 --> 00:46:12.109
know what its problem is, but running it twice
seems to be working. And in fact that's correct,

00:46:12.109 --> 00:46:16.779
so it looks like all of our methods are working
well at this point. Let's talk a little bit

00:46:16.779 --> 00:46:21.230
about some implementation notes. We had to
constantly think about what kind of object

00:46:21.230 --> 00:46:27.059
we were using. So notice for example when
we had the set as a parameter, then we had

00:46:27.059 --> 00:46:32.690
to use set.elements, because the set is a
set it's not an ArrayList. So we can only

00:46:32.690 --> 00:46:38.259
use on the set the things that are in the
set class. If this gets confusing for you

00:46:38.259 --> 00:46:44.450
one thing you can do is to declare variables
of the given type and assign them. I found

00:46:44.450 --> 00:46:48.279
that this help students who are struggling
with the differences between different types

00:46:48.279 --> 00:46:53.749
of objects to understand how these things
works. Always make sure that you differentiate

00:46:53.749 --> 00:46:59.440
the implicit objects from the parameter objects.
One way to do that is by explicitly using

00:46:59.440 --> 00:47:03.569
this every time, and if that makes you more
comfortable there's no problem with using

00:47:03.569 --> 00:47:10.569
it. Also remember-- do simple operations instead
of compound operations. I sometimes will nest

00:47:11.210 --> 00:47:15.499
operation two or three levels deep, but when
it gets any deeper than that it's very hard

00:47:15.499 --> 00:47:20.809
to read and it's very hard to debug. So keep
it simple. The next thing we need to consider

00:47:20.809 --> 00:47:27.109
is to design of the tutor class. For instance
data we should have the number of correct

00:47:27.109 --> 00:47:31.509
and wrong answers, because remember, the tutor
class is just going to be checking on whether

00:47:31.509 --> 00:47:35.960
the students have done the set operations
correctly. We also are going to need to have

00:47:35.960 --> 00:47:40.999
class data that stores the number of times
the tutor should be run. Now we also could

00:47:40.999 --> 00:47:47.190
ask the user to enter it or we could generate
it randomly, but this an easy way to do that.

00:47:47.190 --> 00:47:51.700
There also should be constants for the operations.
Now the reason we do this is to keep the code

00:47:51.700 --> 00:47:58.529
maintainable so we can add more set operations
on if they come in later. The main method

00:47:58.529 --> 00:48:02.509
could be put in a separate class if we wanted
to, but if we did that we're going to have

00:48:02.509 --> 00:48:07.690
to create accessors and mutators for the number
of correct and wrong answers. And there's

00:48:07.690 --> 00:48:12.369
really no reason to do that, so I'm going
to put the main method in the same class.

00:48:12.369 --> 00:48:17.690
Now there's some tricks to doing this so pay
attention to how it actually works. The other

00:48:17.690 --> 00:48:22.329
thing we'll need of course is a constructor,
because since we have instance data we have

00:48:22.329 --> 00:48:29.329
to be able to construct it. Our last method
is going to be show and test random operation.

00:48:29.680 --> 00:48:33.789
Now this method actually got fairly long when
we were doing it and we'll talk about whether

00:48:33.789 --> 00:48:38.420
that's a problem later. This will return true
if the student answers correctly and false

00:48:38.420 --> 00:48:43.950
otherwise. So basically, this method is hiding
all the details of how the student does the

00:48:43.950 --> 00:48:50.950
set operation successfully. Now why is this
a class method? That's really counterintuitive.

00:48:51.230 --> 00:48:55.710
Well the reason is because we're returning
a Boolean that tells whether the student was

00:48:55.710 --> 00:49:01.049
successful or not, we don't need to update
the instance data which is the number of correct

00:49:01.049 --> 00:49:05.970
answers and the number of wrong answers. So
that's why this is a class method. Now the

00:49:05.970 --> 00:49:10.289
way to tell this when you're implementing
it if you didn't get it right in the design

00:49:10.289 --> 00:49:17.289
is to recognize that you didn't use the instance
data in the method itself. Now this dummy

00:49:17.430 --> 00:49:22.369
test program we may want to keep or we may
want to get rid of eventually. For right now

00:49:22.369 --> 00:49:28.289
I'm just getting it off the screen so I don't
get confused by it. So here's our tutor class.

00:49:28.289 --> 00:49:32.339
We have two pieces of instance data: the number
of correct answers and the number of wrong

00:49:32.339 --> 00:49:36.670
answers. Now notice these are instant data,
so we're going to have to have an object from

00:49:36.670 --> 00:49:42.059
this class. We also have a constant for the
total number of exercises. Now I made that

00:49:42.059 --> 00:49:48.119
constant public, because I think people outside
of this class might want to use it. Now you

00:49:48.119 --> 00:49:52.789
could also make it private. In general it's
better to always make things private if you

00:49:52.789 --> 00:49:57.339
can rather than make things public. So you
could go either way on this one. It never

00:49:57.339 --> 00:50:02.299
does any harm really to make a constant public.
Since a constant can't be changed, there's

00:50:02.299 --> 00:50:07.470
no risk but on the other hand, you want to
be very judicious about how to do it. Once

00:50:07.470 --> 00:50:11.519
you've made something public you can't go
back to private. So notice that when I was

00:50:11.519 --> 00:50:15.989
creating constants for the five different
operators that we're going to test, I did

00:50:15.989 --> 00:50:21.079
make those private. This is the internal logic
of the program and nobody else needs to be

00:50:21.079 --> 00:50:26.220
privy to that. So those constants definitely
don't need to be public. Let's take a look

00:50:26.220 --> 00:50:31.069
at what our constructor does. Remember the
goal of a constructor is always to initialize

00:50:31.069 --> 00:50:36.230
the instance data, so it sets the number of
right answers and the number of wrong answers

00:50:36.230 --> 00:50:43.230
to 0 just like it should. Now here's our main
program. So we need to think through what

00:50:43.359 --> 00:50:48.210
we need to do. Well we're going to need to
create a tutor object, then we're going to

00:50:48.210 --> 00:50:52.960
need to give the total number of exercises,
keeping track of whether the answers were

00:50:52.960 --> 00:50:58.069
right or wrong and then give some feedback
to the user. So that's our goal. So let's

00:50:58.069 --> 00:51:05.069
write that down. Now this is the step that
everybody forgets, is that even though we're

00:51:07.599 --> 00:51:12.009
in the main program here we need to have a
tutor object, even though we're in the tutor

00:51:12.009 --> 00:51:18.499
class. Remember the main program is a class
method. It's not an instance method, so there

00:51:18.499 --> 00:51:23.319
is no implicit instance hanging around. If
we want an instance in this class we need

00:51:23.319 --> 00:51:28.430
to construct it. To make matters worse, this
is one of those things that Eclipse does not

00:51:28.430 --> 00:51:34.180
indicate very clearly. It will complain about
things that really are hard to interpret.

00:51:34.180 --> 00:51:41.180
So be aware the fact that that's a problem.
So, we now have a tutor object that's properly

00:51:41.430 --> 00:51:48.430
initialized. We're going to have to give the
user total exercises, so let's create a for

00:51:51.249 --> 00:51:58.249
loop for that. Exercise is 0 exercise less
than total exercises plus plus exercise. So

00:52:12.359 --> 00:52:16.239
there's our loop, as you can see it's off
the screen, so we're going to do the usual

00:52:16.239 --> 00:52:23.059
thing and move it down a little bit keep our
code visible. We need to know what our method

00:52:23.059 --> 00:52:30.059
is going to look like. So here it is-- show
and test random operation. Now we haven't

00:52:30.470 --> 00:52:35.289
looked at the details of this method, but
what it's doing is displaying operations to

00:52:35.289 --> 00:52:40.170
the user allowing them to enter it and it's
returning true or false if they did it successfully.

00:52:40.170 --> 00:52:44.720
We'll look at the method in a few minutes
but for right now we're just going to use

00:52:44.720 --> 00:52:49.420
it. It's okay to use methods when you haven't
read them. So show and test random operation

00:52:49.420 --> 00:52:56.420
[typing] and notice it's taking a, it needs
an argument from our scanner. I don't know

00:53:01.769 --> 00:53:08.769
if I created a scanner yet, looks like I didn't
so I better do that. So there we go. Now this

00:53:18.059 --> 00:53:25.059
is telling whether the user was successful
or not. So we better store that...and then

00:53:31.390 --> 00:53:38.200
give the user some feedback. So if result
now notice that I did not say result equals

00:53:38.200 --> 00:53:44.410
equals true. Result equals equals true actually
means the same thing as result just by itself.

00:53:44.410 --> 00:53:48.799
This is really more a style thing than anything
else. If you put result equals equals true

00:53:48.799 --> 00:53:53.749
in your code people are going to look at your
code and say wow, did you just start programming?

00:53:53.749 --> 00:53:57.339
So I'd rather have your code look a little
bit more professional, but if you need the

00:53:57.339 --> 00:54:02.710
equals equals true there to know what it's
doing-- that's just fine. But think about

00:54:02.710 --> 00:54:08.109
it: if result is true, result equals equals
true is true. If result is false, result equals

00:54:08.109 --> 00:54:15.109
equals true is false. So there is no value
for that equals equals true. So if it's true,

00:54:15.950 --> 00:54:22.950
then we'll give the user some feedback. You
got it right! Users are always excited about

00:54:23.910 --> 00:54:30.910
that, and we want to encourage it. Now we
need to increment the number of points. Now

00:54:31.039 --> 00:54:38.039
remember that we can't just access our variables,
called it correct answers. We can't do this,

00:54:45.880 --> 00:54:50.529
as Eclipse is telling us. Now let's take a
look at this error message. Can't make a static

00:54:50.529 --> 00:54:55.440
reference to a non-static field. Now that's
one of those error messages that is not very

00:54:55.440 --> 00:55:01.239
helpful. So let's take that error message
apart and see what it really means. Cannot

00:55:01.239 --> 00:55:08.140
make a static reference, so you can't use
a class method to get to instance data. So

00:55:08.140 --> 00:55:12.809
that's what a non-static field is. So what
it's saying is hey wait a minute, you're in

00:55:12.809 --> 00:55:18.140
a class method you don't have an implicit
object. You have to tell me which object.

00:55:18.140 --> 00:55:25.140
Now we have the object it's called this tutor
and notice that removes that problem. So these

00:55:26.859 --> 00:55:32.170
are the very subtle points of using class
methods and instance methods together. And

00:55:32.170 --> 00:55:39.170
now let's tell the user how many correct answers
they have. Okay and we've scrolled off the

00:55:55.660 --> 00:56:02.660
screen again, so we definitely want to fix
that. This one may be a little trickier to

00:56:03.979 --> 00:56:10.979
fix, because we're running out of real estate
but that looks good. Now we also have to consider

00:56:12.069 --> 00:56:18.109
the case when it's wrong. Whoops, we don't
need to put a test in here because there are

00:56:18.109 --> 00:56:25.109
really only two possibilities: they did it
correctly or they didn't do it correctly.

00:56:25.479 --> 00:56:32.479
So let's grab our code. Probably don't want
that exclamation point on wrong, may want

00:56:43.079 --> 00:56:50.079
to think about whether that's polite or not.
Of course as always when we cut-and-paste

00:56:53.670 --> 00:56:59.019
code, you need to read it very carefully to
make sure that you get everything, that you

00:56:59.019 --> 00:57:06.019
get all the comments and everything correct.
So let's be a little nicer here. I'm sorry

00:57:07.259 --> 00:57:14.259
but you got it wrong. Remember, it never pays
to be rude to anyone. This has gotten long

00:57:14.519 --> 00:57:21.339
and it's off the screen, so the way we fix
that is this remember it's not legal to break

00:57:21.339 --> 00:57:26.710
a string over lines. That's an annoying little
Java thing and you can also see we need a

00:57:26.710 --> 00:57:33.019
space here because we want a space between
the word it and the word wrong. Okay, so when

00:57:33.019 --> 00:57:40.019
we get to the end of the tutor what we want
to do is to give the user some feedback. Now

00:57:45.309 --> 00:57:50.549
we have not marked which curly brace is which,
and because our code has gotten a little bit

00:57:50.549 --> 00:57:57.549
longer it's probably a good thing to do. So
this is the end of the for loop. Now we might

00:58:01.380 --> 00:58:07.529
wonder why that is indented so much. Ahhh,
and what we see is we indented one time too

00:58:07.529 --> 00:58:13.380
many. Well that explains why everything was
going off the screen. Well that's annoying.

00:58:13.380 --> 00:58:18.239
So we definitely want to undo that, so to
undo it what you do is you select it and then

00:58:18.239 --> 00:58:23.369
you do shift tab and that bounces it over
one position. And notice now everything is

00:58:23.369 --> 00:58:30.369
fitting on the screen better, so this looks
much better now. So let's give the user some

00:58:32.150 --> 00:58:39.150
feedback at the end of the program. You had
this tutor.correct answers correct answers,

00:59:01.979 --> 00:59:08.979
two r's in correct and system out print line.
You had this tutor.wrong answers, wrong answers.

00:59:24.599 --> 00:59:28.029
One thing we want to be sure is that they
either both end with a period or neither ends

00:59:28.029 --> 00:59:33.609
with a period, so things look good. Looks
like we have the spaces in the right place,

00:59:33.609 --> 00:59:40.609
so now we're ready to actually run the tutor.
So here we go. Find 9, 0, 6 complement. If

00:59:46.160 --> 00:59:50.710
we were doing our formal testing now we'd
want to write which operations we've actually

00:59:50.710 --> 00:59:57.710
seen to make sure that we see every operation
multiple times. This is really important because

00:59:58.259 --> 01:00:01.869
we're doing things randomly, which means that
we might not see some of these operations

01:00:01.869 --> 01:00:06.729
for a while. So the complement operation,
remember, is the elements that are in the

01:00:06.729 --> 01:00:13.729
universal set that are not in this set. So
we have 1, 2, 3, 4, 5, not 6 because it's

01:00:13.950 --> 01:00:20.950
in the set 7, 8, 9 is in the set so it's not
in the complement and then 10. Hey I got it

01:00:25.299 --> 01:00:30.049
right! Now something interesting happened,
we got a complement again. We might think

01:00:30.049 --> 01:00:35.950
about whether that's random enough or not.
So 6, 1, 3 complement, well 0 isn't in the

01:00:35.950 --> 01:00:42.950
set, 2 isn't in the set, 4 isn't in the set,
5 isn't, 6 is then 7, 8, 9 and 10. One of

01:00:46.190 --> 01:00:51.390
the problems with the program as it's written
is this interface is very fragile to mistakes

01:00:51.390 --> 01:00:56.700
with curly braces and commas. As you might
guess when I was parsing the input I used

01:00:56.700 --> 01:01:02.220
that spilt operation again that we've used
several times. So if people forget a comma,

01:01:02.220 --> 01:01:06.729
they're in trouble. So that's something we
could probably improve. I'll probably make

01:01:06.729 --> 01:01:12.519
a mistake and break this program one of these
times. Okay so now we're seeing a set difference.

01:01:12.519 --> 01:01:16.849
Good to see a different operator that makes
us little bit less suspicious. 3 is in the

01:01:16.849 --> 01:01:21.950
first set and in the second set so it's not
in the result, 6 is in both the first and

01:01:21.950 --> 01:01:26.970
second set so its not in the result, 2 on
the other hand is in the first set but not

01:01:26.970 --> 01:01:33.259
the second, 9 is in both so it's not in it,
8 is in the first set but not in the second,

01:01:33.259 --> 01:01:39.499
5 is in the first set but not the second,
and 7 is the first set but not the second.

01:01:39.499 --> 01:01:43.329
Notice the fact that we have things like 0
that are in the second set but not in the

01:01:43.329 --> 01:01:50.329
first doesn't matter. So set difference is
one of the only operations that is not symmetric.

01:01:50.359 --> 01:01:55.400
So there we go. Now, this next one is kind
of interesting because it has the empty set.

01:01:55.400 --> 01:01:59.509
So it's good to see that it means it could
be randomly generated and also we might want

01:01:59.509 --> 01:02:04.469
to think about what our answer is going to
be. Well if there's nothing in the set there's

01:02:04.469 --> 01:02:08.729
nothing to remove, so our answer is going
to be the empty set. So this is a good test

01:02:08.729 --> 01:02:14.299
for the software. We haven't tested the universal
set either. So everything's working well so

01:02:14.299 --> 01:02:19.569
far. One thing we have not tested is a wrong
answer, so that's something we certainly should

01:02:19.569 --> 01:02:24.900
continue. So let's give a wrong answer here.
So that is certainly not the intersection

01:02:24.900 --> 01:02:30.289
of those two sets, so let's read this carefully
and make sure that it makes sense. It tells

01:02:30.289 --> 01:02:35.719
me what the correct answer is, says I'm sorry
you got it wrong. You have one wrong answer.

01:02:35.719 --> 01:02:41.440
Okay that looks good. Now we have another
intersection coming up. Let's do this one

01:02:41.440 --> 01:02:48.440
correctly. So 6 is in the intersection 7 is
not, 10 is not, so it's just 6. This is actually

01:02:50.349 --> 01:02:56.440
another good boundary condition, because it's
a single element set. Okay here's another

01:02:56.440 --> 01:03:02.499
set difference. Notice we haven't seen a union
yet, that's kind of annoying. Let's hope we

01:03:02.499 --> 01:03:09.499
see one soon. 6, 2, 7, this actually is a
boundary condition sort of too, because in

01:03:10.289 --> 01:03:14.729
this case there are no elements of the second
set that were in the first set. So you can

01:03:14.729 --> 01:03:19.700
think of that as being another boundary, that
looks like it's working well. It seems like

01:03:19.700 --> 01:03:25.329
we're getting a lot of set differences, that
happen sometimes with random numbers. So 3

01:03:25.329 --> 01:03:31.489
is going to be in the set difference, 9 is,
0 is not because it's in both sets, and 5

01:03:31.489 --> 01:03:37.509
is. We're going to want to go back and count
these and make sure. Oh here's a complement,

01:03:37.509 --> 01:03:44.509
good, that's another one. 1, 2, 3, not 4,
5, not 6, 7, not 8, 9 and 10. Whoops! I was

01:03:50.619 --> 01:03:55.670
afraid I was going to do that. So if you take
a look at what I did wrong, I used a period

01:03:55.670 --> 01:04:01.589
instead of a comma and the program broke.
This is the fragile nature of the input. That's

01:04:01.589 --> 01:04:04.670
something that you might want to improve if
you're going to work on this program a little

01:04:04.670 --> 01:04:09.940
bit. Now we haven't seen a union yet and we
haven't fully tested, but we have seen most

01:04:09.940 --> 01:04:16.940
of our code. Oh yes. Let's go and take a look
at that random operation class, because that's

01:04:18.670 --> 01:04:22.019
sort of some interesting code. Now the first
thing I'm going to do is give you a little

01:04:22.019 --> 01:04:27.839
bit more screen real estate here because this
code got fairly long, and I'll talk little

01:04:27.839 --> 01:04:32.489
bit about whether that's a good thing or a
bad thing. The first thing I did was create

01:04:32.489 --> 01:04:37.839
three sets: set one, set two and a results
set. Then we have an integer called element

01:04:37.839 --> 01:04:43.799
and a string for the user input and a result.
Now I set it initially to false but it will

01:04:43.799 --> 01:04:50.799
actually be returned when it's given a value.
So the first thing we do is we pick the operation

01:04:51.450 --> 01:04:56.309
randomly. Now we might want to think about
the fact that we have not seen an element

01:04:56.309 --> 01:05:02.099
of method coming up here. That actually may
be a bug in this code. If we think about it,

01:05:02.099 --> 01:05:07.009
when we multiply a random by element of we've
got a problem because when it gets truncated

01:05:07.009 --> 01:05:14.009
as an integer, it's one less. So this probably
should have been element of +1. Think back.

01:05:17.339 --> 01:05:21.670
Did you see any element of's in our code?
You did not, so that's an indication of a

01:05:21.670 --> 01:05:26.969
weakness in our testing strategy and a bug
in the program. So the first thing I did was

01:05:26.969 --> 01:05:33.200
create the random sets. Now the reason they're
created this way is we created these methods

01:05:33.200 --> 01:05:38.569
as instance methods. Since they're instance
methods you have to call them from an instance.

01:05:38.569 --> 01:05:42.460
These could have been created as class methods
and we'll talk about an advantage of doing

01:05:42.460 --> 01:05:48.369
it that way in a few minutes. Then we created
a random element. Now this is kind of a weird

01:05:48.369 --> 01:05:53.999
strategy, because not all of these operators
have two set arguments. Some of them only

01:05:53.999 --> 01:05:58.869
have one, like element of and some of them
don't have an element as an argument, but

01:05:58.869 --> 01:06:03.619
what I chose to do here was to create all
three of them at the start and then use them

01:06:03.619 --> 01:06:07.969
or not as the operation required. It keeps
the code a little bit shorter and a little

01:06:07.969 --> 01:06:13.489
bit cleaner, and so that's why I did it this
way. So first we have if the operation is

01:06:13.489 --> 01:06:20.489
a union, then we find set 1 plus set 2. So
the method that's being called here is to

01:06:21.690 --> 01:06:28.690
string. That's one of our Java conventions.
Then we get the user input, we parse it and

01:06:30.069 --> 01:06:35.920
then we see if the result set equals the result
of the operation. So we basically are using

01:06:35.920 --> 01:06:42.289
our equals method here to compare what happens
with the union to what the user thinks happens.

01:06:42.289 --> 01:06:48.019
Then if the user didn't do it correctly, we
print out the answer. Now the reason that

01:06:48.019 --> 01:06:53.190
I had to print out the result here is remember,
this method could only return one thing. Since

01:06:53.190 --> 01:06:58.460
we're returning whether it was correct or
not we can't also return the result. And so

01:06:58.460 --> 01:07:03.059
that forces us to print out the result here.
Now this is a case where it's not a very elegant

01:07:03.059 --> 01:07:08.670
solution. Usually we don't like our results
to be printed out and other methods, we would

01:07:08.670 --> 01:07:13.400
like to keep the system out print lines in
one method as much as it's possible. It just

01:07:13.400 --> 01:07:20.400
wasn't possible here. So we do the same thing
for the intersection methods and for set difference

01:07:20.779 --> 01:07:26.710
these are all binary operations so they have
two arguments. Now complement remember is

01:07:26.710 --> 01:07:32.489
a unary operation, it has only one argument.
So we're finding the complement of set one

01:07:32.489 --> 01:07:38.489
and doing the same comparison. Element of
is a little bit different. It's a binary operator

01:07:38.489 --> 01:07:45.249
but it's a binary operator between a set and
an element. So what we do is ask whether the

01:07:45.249 --> 01:07:49.210
element is in the set. Incidentally, this
is another little weakness in this program.

01:07:49.210 --> 01:07:54.460
We're using the next Boolean method to read
in the data now. Next Boolean is not the most

01:07:54.460 --> 01:07:59.150
forgiving method in the world. We might do
a little bit better as reading it as a string

01:07:59.150 --> 01:08:05.319
and then processing it ourselves to cover
little mistakes. So we check to see if it's

01:08:05.319 --> 01:08:09.890
the same, incidentally, I think a couple of
parentheses there might make that a little

01:08:09.890 --> 01:08:16.890
bit easier to read. And if it is not the same
then we print out the result. Now another

01:08:18.440 --> 01:08:22.550
thing that I've done here in this code that
I strongly encourage you to do is to put an

01:08:22.550 --> 01:08:28.710
else statement in when you get an unanticipated
operation. What that does is flags if you're

01:08:28.710 --> 01:08:34.140
off by one by having one too many. Now notice
it didn't catch having one too few, we had

01:08:34.140 --> 01:08:39.220
to catch that by hand in our testing of the
method. So the last thing we do is return

01:08:39.220 --> 01:08:44.190
the result. So it's sort of an interesting
program. Now one thing you may notice: this

01:08:44.190 --> 01:08:51.190
method ended on line 150 and it started on
line...69. So this line method was more than

01:08:56.980 --> 01:09:02.330
70 lines long. That is far more than a single
page. And remember, we don't usually like

01:09:02.330 --> 01:09:07.640
methods that are long like this. We could've
pulled it apart into smaller methods. So for

01:09:07.640 --> 01:09:14.640
example we could have taken these individual
tests here, for example, between 94 and 99

01:09:15.730 --> 01:09:20.790
and passed them in, but there's a reason that
I didn't do it that way. The user input you

01:09:20.790 --> 01:09:25.210
want to be very, very, consistent and when
you start separating them out into different

01:09:25.210 --> 01:09:30.470
methods then it's much harder to see if the
user input is extremely consistent. So by

01:09:30.470 --> 01:09:35.670
leaving it together I actually make it easier
to maintain the code. So we don't make methods

01:09:35.670 --> 01:09:41.420
short just for the joy of making them short.
We make them short for strategic purposes

01:09:41.420 --> 01:09:46.620
to make the code easier to maintain. If that
strategic purpose isn't there, then we don't

01:09:46.620 --> 01:09:51.790
do it. There's always some judgment involved
in these software engineering decisions, and

01:09:51.790 --> 01:09:56.970
in my judgment having this method long makes
the code easier to read and maintain than

01:09:56.970 --> 01:10:03.970
having it short. Now if you disagree, that's
okay. You know these things aren't absolutes.

01:10:05.390 --> 01:10:09.240
So one thing we might want to think about
is what is the class relationship between

01:10:09.240 --> 01:10:14.610
the set class and the tutor class? Is it aggregation
or is it uses? Well if you think about the

01:10:14.610 --> 01:10:20.410
tutor class, it had two instance data elements
and they were both ints. So there's no instance

01:10:20.410 --> 01:10:26.280
data from the set class. That means it's definitely
a uses relationship. But remember, even if

01:10:26.280 --> 01:10:31.390
we had a set operation in the tutor class,
if the set wasn't sort of part and parcel

01:10:31.390 --> 01:10:37.520
of the class if it wasn't a meaningful component
it wouldn't be in aggregation relationship.

01:10:37.520 --> 01:10:43.740
If we're going to show this in UML, we would
show it with a dotted line with an open arrowhead.

01:10:43.740 --> 01:10:48.780
When we implement the tutor class method remember
we had to watch out for the instance and class

01:10:48.780 --> 01:10:53.070
differences. Those are things that really
cause a lot of trouble. And we thought about

01:10:53.070 --> 01:10:58.160
whether the show and test random operation
method should be broken up into smaller methods.

01:10:58.160 --> 01:11:01.000
That might be something you want to think
about a little bit more and see what your

01:11:01.000 --> 01:11:07.190
answer would be. We've tested the tutor, we've
checked for empty sets, but we didn't actually

01:11:07.190 --> 01:11:12.580
check universal sets other than indirectly.
Because we did a complement operation we did

01:11:12.580 --> 01:11:18.150
see universal set in that. So we've kind of
checked it, not really well. Of course we

01:11:18.150 --> 01:11:22.880
checked right and wrong answers. We didn't
check duplicate elements though. This is why

01:11:22.880 --> 01:11:27.130
it's always good to have a testing plan, as
we forgot to test that. So let's go back and

01:11:27.130 --> 01:11:34.130
do just little bit more testing. Okay, so
we see the intersection here is just 7. So

01:11:41.350 --> 01:11:48.280
let's enter 7, 7, 7, 7, 7, which by the way,
is a correct answer and is being recognized

01:11:48.280 --> 01:11:55.280
as a correct answer. That's good. Now here
we have a set difference operation, the 0

01:11:55.570 --> 01:12:00.240
notice is going to be removed. So our answer
is going to be and I'm going to go really

01:12:00.240 --> 01:12:07.240
crazy with this one, whoops! Getting carried
away with those commas. Now that's actually

01:12:18.580 --> 01:12:23.410
a correct answer, albeit kind of a crazy one,
and it's been recognized as correct. Now this

01:12:23.410 --> 01:12:29.390
is nice. Notice that our fix has actually
resulted in us seeing that element of operation.

01:12:29.390 --> 01:12:36.390
So 8 is then the empty set. No, I don't think
so. So we got that right. 3 is in the set

01:12:38.100 --> 01:12:45.100
containing 1. No I don't think so. Now here
we have another intersection, that's kind

01:12:48.210 --> 01:12:53.810
of interesting. Something actually went wrong
there. Notice that I didn't enter anything

01:12:53.810 --> 01:12:58.580
and that went ahead. Now if you think about
that, that's going to be another one of those

01:12:58.580 --> 01:13:03.120
new line problems. So we actually did find
a bug in our program by doing a little bit

01:13:03.120 --> 01:13:10.120
more testing. So, we know that's going to
be here. Notice that we have that next Boolean?

01:13:11.050 --> 01:13:16.190
Well just like next int and next double, that
leaves the new line character hanging around.

01:13:16.190 --> 01:13:23.190
So what we have to do is keyboard.next line
to remove that. Okay, here we go. Testing

01:13:28.150 --> 01:13:35.150
again we've got a set difference. So we've
got 10 and 6 right? That looks good. Now we

01:13:38.020 --> 01:13:42.370
still haven't seen any union operations and
you know what, I'm getting suspicious that

01:13:42.370 --> 01:13:47.390
maybe we've got something wrong there too.
So let's go back and look see why union might

01:13:47.390 --> 01:13:53.310
not be included. So we need to look and see
what it's constant is and then see what's

01:13:53.310 --> 01:14:00.310
going on, because we've done way too many
operations not to see a union. So union is

01:14:02.890 --> 01:14:09.890
operation 0. Oh oh oh that is painful, isn't
it? Notice it's a boundary condition. So we've

01:14:09.990 --> 01:14:15.110
got a boundary condition that isn't working.
Those things kill us every time. So let's

01:14:15.110 --> 01:14:19.300
go and look and see where we were choosing
operations because that's going to be where

01:14:19.300 --> 01:14:26.300
the problem is. So that's in this big ginormous
method. Okay, so let's see what happens here.

01:14:28.580 --> 01:14:35.580
Math.random times element of +1. So we're
taking a random value, which remember is between

01:14:35.890 --> 01:14:42.890
0 and .999, and we're multiplying by element
of +1. Well element of +1 would be 5, because

01:14:45.250 --> 01:14:52.250
element of is 4, so we should be going between
0 and 4.99999. Hmmm. That seems like it should

01:14:54.640 --> 01:15:01.640
be correct. We need to check that our parentheses
are right, that these are actually being multiplied

01:15:01.730 --> 01:15:08.040
and that the cast is occurring after the multiplication
occurs, which is true. Now what I'm going

01:15:08.040 --> 01:15:15.010
to do to test this is I'm going to put in
a little loop here. This is what is called

01:15:15.010 --> 01:15:22.010
destructive testing and it's dangerous to
some degree, because what you're doing is

01:15:23.540 --> 01:15:30.540
actually damaging your code. So what we want
to do is print this out now 100 times, and

01:15:32.800 --> 01:15:37.020
see if 0 ever occurs. If it doesn't occur
then we're going to have to do some more thinking

01:15:37.020 --> 01:15:44.020
about what could be going wrong. So what we're
expecting to see is values between 0 and 5

01:15:47.440 --> 01:15:54.440
inclusive. Let's see if that's what happens.
Whoops, looks like I broke something while

01:15:56.590 --> 01:16:03.590
I was doing that. Oh I see what I broke. Because
I declared operation inside the for loop,

01:16:07.710 --> 01:16:12.440
that means our other methods can't see it.
Incidentally never try to go on and run, because

01:16:12.440 --> 01:16:17.510
if you go on and run after that what happens
is it's running old code. It's not running

01:16:17.510 --> 01:16:23.220
the code you just modified. So here's the
fix. Now remember, we're going to have to

01:16:23.220 --> 01:16:30.220
undo this when we're through. Another error?
Well let's see what's going on here. It still

01:16:36.330 --> 01:16:43.330
isn't liking union. I'm sorry, it still isn't
liking operation in any of these. So let's

01:16:49.210 --> 01:16:56.210
see what happened. I declared it outside of
my for loop, so that's good. There's the end

01:16:59.210 --> 01:17:06.210
of the for loop. It seems like it should be
seeing that. Let's see, do we have a curly

01:17:07.330 --> 01:17:14.330
brace that's out of whack? The other thing
I'm doing is moving the comment over to make

01:17:15.120 --> 01:17:22.120
sure that there's nothing that's wrong there.
Well that's kind of strange. Now I'm leaving

01:17:26.390 --> 01:17:33.390
my for loop badly indented, mostly so that
I remember to remove it. Did I spell it wrong

01:17:40.280 --> 01:17:47.280
maybe? That's always something to look for.
Operation looks like it's spelled correctly.

01:17:48.540 --> 01:17:55.540
Ahhh, the local variable may not have been
initialized. That's bull, it was initialized.

01:17:56.370 --> 01:18:01.750
This is one of those cases where Eclipse is
being ridiculously cautious. So the way that

01:18:01.750 --> 01:18:07.330
you defeat that is just by initializing it
to 0 and notice now it's fine with everything.

01:18:07.330 --> 01:18:14.330
So we have even more code we need to delete
at the end. So here we go. So notice we are

01:18:14.410 --> 01:18:21.410
getting some 0's here. It doesn't look like
we're getting many 0's for some reason, but

01:18:23.870 --> 01:18:28.550
that probably just has to do with the exact
random number generator. So actually our suspicion

01:18:28.550 --> 01:18:35.550
about this turns out to be unfounded but now
we know that it's true so that's a good thing

01:18:35.930 --> 01:18:42.000
to do. Now remember we have to remove all
that code or we're going to have problems

01:18:42.000 --> 01:18:49.000
in our program. So we declared this as an
int. We did not have that there. And of course

01:18:53.890 --> 01:19:00.010
we don't want to leave the system out print
line hanging around. The other thing we must

01:19:00.010 --> 01:19:07.010
do now is run the program again. Oh my goodness
and now Eclipse is freaking out. This probably

01:19:10.670 --> 01:19:17.670
means that we've got a curly brace that's
in the wrong place. Yeah. Right there it is.

01:19:20.130 --> 01:19:26.640
I told you that destructive testing was dangerous.
Notice that one curly brace caused about 15

01:19:26.640 --> 01:19:33.540
different mistakes. Bad stuff. Okay, so now
we need to stop this from running and we need

01:19:33.540 --> 01:19:37.920
to run our program again, because any time
you do destructive testing you always need

01:19:37.920 --> 01:19:44.920
to be suspicious. So this is true and now
we're looking for complement. So 1, not 2,

01:19:47.230 --> 01:19:54.230
3, 4 not 5, 6, 7, 8, not 9 and 10. And we
might want to do something that's wrong here,

01:19:56.710 --> 01:20:03.290
so let's just give a set with 0. And it gives
the correct answer and now it looks like things

01:20:03.290 --> 01:20:07.710
are running well. So we've actually done a
little bit of debugging in our program. Of

01:20:07.710 --> 01:20:13.630
course we're nowhere close to having completely
tested this program. So we've tested our duplicate

01:20:13.630 --> 01:20:17.420
elements. Now notice the bugs we've found
while we were doing testing didn't actually

01:20:17.420 --> 01:20:21.740
have anything to do with duplicate elements.
That is a sure sign that we have not tested

01:20:21.740 --> 01:20:26.620
this program enough. The next thing we want
to talk about is whether our set class is

01:20:26.620 --> 01:20:31.530
or is not immutable. So we need to look at
the methods carefully and see if there's any

01:20:31.530 --> 01:20:37.300
methods that change data. Now remember, being
immutable is a highly desirable property,

01:20:37.300 --> 01:20:42.290
something that we may want to consider making
the class even if it isn't so far. Now as

01:20:42.290 --> 01:20:47.740
far as why it's desirable, the nice thing
about immutable objects is the fact they can't

01:20:47.740 --> 01:20:52.960
be messed up. Once they've been constructed,
if they have the right data, they they can't

01:20:52.960 --> 01:20:58.200
be changed in any way. So for example the
string class is immutable. It does come with

01:20:58.200 --> 01:21:02.400
a downside, however. Every time you create
a new set you're going to have to create a

01:21:02.400 --> 01:21:07.860
new object if it's immutable. So we might
want to think about whether this is desirable.

01:21:07.860 --> 01:21:13.040
In this particular case because the sets we're
creating are relatively small, it's okay to

01:21:13.040 --> 01:21:17.990
create many of them. But on the other hand,
we might really think carefully about whether

01:21:17.990 --> 01:21:22.500
this is desirable, but first let's figure
out whether the class is immutable as we've

01:21:22.500 --> 01:21:26.900
written it and whether we would be able to
make it immutable. So we go back to the set

01:21:26.900 --> 01:21:33.900
class now. So here's our set class. I'm going
to go through the methods one at a time and

01:21:42.770 --> 01:21:47.940
see if they're are immutable. Now remember,
whoops! That's the tutor class, that's not

01:21:47.940 --> 01:21:54.940
the right one. Here's our set class. Okay,
so we don't know anything about whether class

01:21:59.820 --> 01:22:06.440
is immutable or immutable just by looking
at its instance data. Constructing an empty

01:22:06.440 --> 01:22:13.440
set, that's perfectly fine. Here's constructing
a set from given data really a constructor

01:22:13.460 --> 01:22:20.460
can't make a class mutable because it's always
building a new object so that's fine. Let's

01:22:20.460 --> 01:22:26.120
get a little more real estate so we can see
more methods. This is also a constructor and

01:22:26.120 --> 01:22:33.120
so that cannot make an object mutable. Remove
duplicates? That isn't going to make an object

01:22:35.050 --> 01:22:40.040
mutable. Now it is going to change the contents
of the set, but it isn't changing the basic

01:22:40.040 --> 01:22:46.920
properties of the set the elements that are
in it. So that one's okay. Now wait a minute,

01:22:46.920 --> 01:22:53.560
look at create random set. That is mutable.
This forces the set class to be mutable. the

01:22:53.560 --> 01:22:58.140
reason is that we're changing the elements
object. So notice here when we reconstruct

01:22:58.140 --> 01:23:04.830
it and then we add new data to it this is
a mutation. Now we might want to think about

01:23:04.830 --> 01:23:10.330
whether this is desirable or not would it
be possible to do this in another way? If

01:23:10.330 --> 01:23:16.140
we want to make this an immutable class, we
would have to change this method. The way

01:23:16.140 --> 01:23:20.910
we could do it is to make it a class method.
So we wouldn't be dealing with the instance

01:23:20.910 --> 01:23:26.790
data in it, but instead just creating a set
object. It's actually not very hard to do.

01:23:26.790 --> 01:23:30.350
So that is something that we might want to
consider if we decide that it's wise to make

01:23:30.350 --> 01:23:35.690
the set class immutable. We have several create
random methods, and so they're going to be

01:23:35.690 --> 01:23:41.920
very much the same. Create random element
notice is a static method, since it doesn't

01:23:41.920 --> 01:23:47.350
deal with the instance data that cannot make
the class immutable. Union notice was written

01:23:47.350 --> 01:23:52.030
in such a way that the union operation is
immutable; we're not changing elements in

01:23:52.030 --> 01:23:58.070
it. And that's actually going to be true for
the way we wrote all of our methods. So set

01:23:58.070 --> 01:24:04.530
difference, element of, is empty, complement,
to string, of course is just taking a set

01:24:04.530 --> 01:24:10.890
and creating a string so that shouldn't be
changing in the set. Equals of course is just

01:24:10.890 --> 01:24:16.070
making comparisons, so that's not going to
change it and here's another one that would.

01:24:16.070 --> 01:24:21.620
So when we have parse notice this is changing
elements. Now would we be able to pull the

01:24:21.620 --> 01:24:26.050
same trick on this that we did on the other
one? Well yes, and in fact we actually thought

01:24:26.050 --> 01:24:30.480
about this when we were doing our design.
Remember I said that parse might work like

01:24:30.480 --> 01:24:36.280
parse int in the math class? Well if you think
about it parse int, that's a class method

01:24:36.280 --> 01:24:41.660
not an instance method. So it looks like we
may have made a couple of design mistakes.

01:24:41.660 --> 01:24:45.840
Now the reason these design mistakes happened
is because we didn't think about mutability

01:24:45.840 --> 01:24:51.120
or immutability soon enough in the design
process. As a result if we want this to be

01:24:51.120 --> 01:24:55.800
an immutable class, we would have to go back
and maintain our code now. So that's why you

01:24:55.800 --> 01:25:02.800
think about these things earlier instead of
later. And that's the end of the class. So

01:25:04.110 --> 01:25:08.420
there actually two tiny little changes we
would have to make and frankly, if I were

01:25:08.420 --> 01:25:13.670
doing this commercially, I would make those
changes right now and have the class be immutable.

01:25:13.670 --> 01:25:18.420
Immutable classes are the source of far fewer
programming bugs and so you definitely want

01:25:18.420 --> 01:25:25.420
to make sure that you make as many classes
immutable as possible. Let's talk a little

01:25:25.460 --> 01:25:29.530
bit about the big picture of the programming
that we've done. The programming trick that

01:25:29.530 --> 01:25:35.120
we just used has a name. It's called a façade.
That may be a word you're not too familiar

01:25:35.120 --> 01:25:39.960
with, so let me explain what a façade is.
It's a fake front. So for example if you go

01:25:39.960 --> 01:25:44.410
down the main street in Norman, Oklahoma,
and you look at the buildings from the side,

01:25:44.410 --> 01:25:48.790
you'll see that some of the buildings are
one story tall but they have fake fronts on

01:25:48.790 --> 01:25:53.940
them to make them look like they're two stories
tall so that Main Street looks nice. This

01:25:53.940 --> 01:26:00.940
is exactly what we did. We hid an ArrayList
inside a set. And we did it successfully,

01:26:01.680 --> 01:26:06.490
in fact somebody who was using the set would
have no idea that that's what we did. So the

01:26:06.490 --> 01:26:12.030
trick here is to hide the implementation details
from the external world. Remember that that's

01:26:12.030 --> 01:26:18.500
also good encapsulation. It appears to outsiders
as if order is not important. Notice we actually

01:26:18.500 --> 01:26:22.460
check that when we were checking our data,
when in fact we're using a data structure

01:26:22.460 --> 01:26:27.190
that has order that is important. It's kind
of a neat trick. If you're interested in tricks

01:26:27.190 --> 01:26:31.450
like that, there's a wonderful book called
"Design Patterns" that you're going to really

01:26:31.450 --> 01:26:36.010
enjoy. You're not quite ready for it yet.
You need another semester of programming to

01:26:36.010 --> 01:26:40.370
know enough programming techniques to make
it understandable and even then it is a major

01:26:40.370 --> 01:26:46.310
intellectual challenge, but it is a truly
wonderful book. Now one thing you may be wondering

01:26:46.310 --> 01:26:52.600
at this point-- doesn't Java have a set class?
Well yes actually, it has several of them.

01:26:52.600 --> 01:26:58.620
It has a new set, it hash set, it has tree
set. Now why didn't we use them? Well one

01:26:58.620 --> 01:27:04.370
problem is complicated syntax. Another problem
is the operations of the set classes were

01:27:04.370 --> 01:27:08.730
given kind of odd names; they weren't called
union and intersection. Now there are some

01:27:08.730 --> 01:27:13.130
very good reasons for this and you'll learn
those next semester if you continue to study

01:27:13.130 --> 01:27:17.130
Java, but that's one of the reasons. And of
course there's the fact that we needed to

01:27:17.130 --> 01:27:22.900
practice some implementation on our own, particularly
dealing with instance methods versus class

01:27:22.900 --> 01:27:28.800
methods. Now one thing you may be wondering
here is why sets are important. It turns out

01:27:28.800 --> 01:27:34.030
that sets are the foundation the mathematics
of computer science. That's really counterintuitive,

01:27:34.030 --> 01:27:41.030
but if you think about it, in element is either
in a set, like 1, or not in a set, like 0.

01:27:42.020 --> 01:27:49.020
It's binary and that's why sets are the mathematical
manifestation of binary digits. In other words

01:27:49.400 --> 01:27:54.280
sets underlie everything we do in computer
science. Now this is a part of mathematics

01:27:54.280 --> 01:27:59.240
that you may not be particularly familiar
with, called discrete mathematics. Mathematics

01:27:59.240 --> 01:28:04.210
is actually divided into two parts. There's
continuous mathematics, which includes things

01:28:04.210 --> 01:28:10.330
like calculus and most of algebra. So for
example between two points there's always

01:28:10.330 --> 01:28:15.690
another point on the number line. Well guess
what? That doesn't work in computer science.

01:28:15.690 --> 01:28:20.590
Our whole world is in the other half of mathematics,
which is the half of mathematics you probably

01:28:20.590 --> 01:28:25.710
have had very little exposure to. This is
a source of great consternation for us computer

01:28:25.710 --> 01:28:30.500
scientists who would like to see junior high
schools and high schools teach more discrete

01:28:30.500 --> 01:28:34.620
math because it's so useful in our field.
So keep programming!

