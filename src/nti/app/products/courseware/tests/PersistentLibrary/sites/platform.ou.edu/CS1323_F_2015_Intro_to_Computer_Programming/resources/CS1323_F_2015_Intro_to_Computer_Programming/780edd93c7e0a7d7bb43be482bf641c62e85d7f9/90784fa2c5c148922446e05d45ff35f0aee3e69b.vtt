WEBVTT
Kind: captions
Language: en

00:00:01.050 --> 00:00:07.800
&gt;&gt;Let's continue our study of complete sets
of operations by looking at environment variables.

00:00:07.800 --> 00:00:13.450
Here's our problem statement: Write a program
that simulates environment variables. Now

00:00:13.450 --> 00:00:19.419
we're going use a bash shell style. This is
typical for a Macintosh computer. I'll give

00:00:19.419 --> 00:00:24.909
you some PC hints along the way too. First
we went to read environment variables from

00:00:24.909 --> 00:00:31.649
a file, then we want to add environment variables
at the console, and then search for environment

00:00:31.649 --> 00:00:37.050
variables from the console. All this might
make more sense if you knew what an environment

00:00:37.050 --> 00:00:42.300
variable was, so let's talk about that a little
bit. Environment variables are used in computer

00:00:42.300 --> 00:00:49.120
systems to describe the location of critical
files. So on a PC you would go to Programs,

00:00:49.120 --> 00:00:54.449
Accessories, Command Prompt, a window will
appear, type the word set and it will show

00:00:54.449 --> 00:00:59.600
you all of the environment variables that
are on your system. On a Macintosh you go

00:00:59.600 --> 00:01:06.600
to the Launchpad, Other, Terminal and enter
the word set. So here we go on my Mac. Here's

00:01:07.180 --> 00:01:13.090
my Launchpad. Now I'm already in Other, remember
normally it would look like this and then

00:01:13.090 --> 00:01:20.090
you would go to Other and here's my Terminal,
and then I'll enter set and a whole bunch

00:01:20.120 --> 00:01:24.820
of stuff is going to go whizzing by. All of
these are the environment variables that are

00:01:24.820 --> 00:01:31.820
currently set in my system, so notice there
are a LOT of them. What exactly gets stored?

00:01:32.940 --> 00:01:39.060
Well, for example the path is stored. What
this is is a list of directories otherwise

00:01:39.060 --> 00:01:44.860
known as folders that the system will search
to find commands. There's one called home

00:01:44.860 --> 00:01:50.110
and what that is the location of my user home
directory. In other words, the default place

00:01:50.110 --> 00:01:57.110
that files get put. There's also something
called histfilesize and what that is the number

00:01:57.140 --> 00:02:02.530
of user commands that are remembered. So it
will actually remember the last 500 commands

00:02:02.530 --> 00:02:08.580
that were typed in. That's kind of useful
sometimes. Now every software program can

00:02:08.580 --> 00:02:15.440
set and use environment variables. We can
actually see and use them in Eclipse. Project,

00:02:15.440 --> 00:02:22.320
Properties, Run and Debug Settings and let
me show you how that looks. So here we are

00:02:22.320 --> 00:02:29.320
in Eclipse, Project, Properties. We're going
to go to this configuration and edit, and

00:02:31.620 --> 00:02:37.280
here are our environment variables. Now in
order to see them you need to to select. So

00:02:37.280 --> 00:02:42.190
notice for example, here's my home directory
sitting right there. That's the same home

00:02:42.190 --> 00:02:48.810
directory that we saw from the Terminal. Here's
my username down here. Now notice some are

00:02:48.810 --> 00:02:53.060
here and other environment variables aren't.
They're only certain ones that are useful

00:02:53.060 --> 00:03:00.060
to eclipse and so that's all it brings in.
Now, how do you use environment variables?

00:03:00.110 --> 00:03:04.840
Well it turns out they're actually stored
in hidden files. The location is dependent

00:03:04.840 --> 00:03:10.600
on the operating system version and configuration.
There's usually a global file that's used

00:03:10.600 --> 00:03:15.600
by everyone, so it's stored in one of the
system directories and then there's another

00:03:15.600 --> 00:03:21.080
additional file that's used individually by
a user. That way you can configure your software

00:03:21.080 --> 00:03:27.700
exactly the way you want. When the system
boots the variables are read from the files.

00:03:27.700 --> 00:03:32.980
Usually the global file is read first and
then the user file is read next. So that gives

00:03:32.980 --> 00:03:39.099
the user a chance to override the things that
are in the global file. Variables can also

00:03:39.099 --> 00:03:46.099
be added at the Terminal or by other programs.
This is done for example at the Terminal by

00:03:46.420 --> 00:03:53.420
typing in export variable = value. Now when
you do this, these don't get written to the

00:03:53.849 --> 00:03:58.670
file when your computer shuts down. This is
actually kind of important-- it turns out

00:03:58.670 --> 00:04:02.910
that if you corrupt these files, if you get
garbage in them you can make your computer

00:04:02.910 --> 00:04:07.970
virtually impossible to use. Sometimes this
gets so bad that you actually have to reinstall

00:04:07.970 --> 00:04:12.730
the operating system if you don't know how
to fix things like this. So these are not

00:04:12.730 --> 00:04:16.639
files you want to be meddling with, and so
I'm not actually going to show you where the

00:04:16.639 --> 00:04:21.789
files are but if you're going to look for
yourself the one you're looking for is usually

00:04:21.789 --> 00:04:28.789
called .bashrc if you're on a Macintosh computer
and it's going to be in your home directory.

00:04:29.180 --> 00:04:33.529
Now it's not going to be visible. Because
the filename starts with a period you can't

00:04:33.529 --> 00:04:40.259
actually see the file so you're going to have
to do ls for list and then a space and negative

00:04:40.259 --> 00:04:45.529
a. If you do that at the Terminal, and you
will see all those files including the ones

00:04:45.529 --> 00:04:52.469
that start with a dot so there might be several
surprises hidden there for you. Now on Windows

00:04:52.469 --> 00:04:58.439
machine this function is handled by the Windows
registry. So it's a database that stores the

00:04:58.439 --> 00:05:04.169
configuration information. If you want to
see the registry there is a way to do it.

00:05:04.169 --> 00:05:10.089
You go to the command prompt, so that will
be under programs, accessories, command prompt

00:05:10.089 --> 00:05:17.089
and type in regedit. Now please be careful
when you do this. Do not change the registry.

00:05:17.969 --> 00:05:22.400
Remember this is the configuration of your
whole computer. If the registry gets mixed

00:05:22.400 --> 00:05:27.210
up badly enough, you're really going to have
trouble. So don't make changes here unless

00:05:27.210 --> 00:05:33.009
you know what you're doing. So when the registry's
corrupted, the operating system can't find

00:05:33.009 --> 00:05:38.870
programs and programs can't find resources.
Now there are ways to corrupt the registry

00:05:38.870 --> 00:05:43.539
other than using regedit, although regedit
works just fine for that purpose. [laughs]

00:05:43.539 --> 00:05:48.430
Low-quality programs for example tend to corrupt
the registry, so if you've been downloading

00:05:48.430 --> 00:05:55.430
a whole bunch of shareware from the Internet
that can be a source of problems. Let's talk

00:05:55.819 --> 00:06:00.339
about what the test data should be for our
program. Well we're going to need to create

00:06:00.339 --> 00:06:06.430
a file of environment variables from the Terminal.
Now I'm going to call it bashrc.txt - like

00:06:06.430 --> 00:06:12.659
I say, I don't want to accidentally overwrite
any of your files anywhere. Certainly we should

00:06:12.659 --> 00:06:17.089
search for the first, the middle, and the
last variable that gets set. This is checking

00:06:17.089 --> 00:06:22.199
the boundary conditions and something in the
middle something we've been doing all semester.

00:06:22.199 --> 00:06:27.020
We want to add new variables too, and search
for the new variables that just got added

00:06:27.020 --> 00:06:31.150
to make sure they're still visible. And of
course after we do that we might search for

00:06:31.150 --> 00:06:35.599
the first, middle, and last variables set
again, just make sure that adding new things

00:06:35.599 --> 00:06:41.689
didn't overwrite old things that we had there.
Now there's something very important going

00:06:41.689 --> 00:06:47.909
on here that I want to call to your attention.
We're about to enter abstraction. Abstraction

00:06:47.909 --> 00:06:53.819
is incredibly important in computer science.
In fact, it's one of the seven principles,

00:06:53.819 --> 00:07:00.129
the seven sort of big intellectual ideas that
computer scientists have to master. So what

00:07:00.129 --> 00:07:07.110
environment variables really are is a relationship
between a key and a value. So the key in this

00:07:07.110 --> 00:07:12.719
case is the name of the environment variable
and the value is the data it refers to. So

00:07:12.719 --> 00:07:17.839
for example we have like the home directory
and then the exact place where it's located

00:07:17.839 --> 00:07:24.839
on my system. This is a very general relationship,
and one that can be reused in many ways. It

00:07:25.990 --> 00:07:32.819
can only be reused if we provide a complete
set of operations. Let me give you some other

00:07:32.819 --> 00:07:39.819
examples of similar things where we could
use the same abstraction. Think about a dictionary.

00:07:39.830 --> 00:07:45.399
You have a key, those of the words in the
dictionary and the value would be the definition.

00:07:45.399 --> 00:07:50.319
So the abstraction that we create for environment
variables would also work for a dictionary

00:07:50.319 --> 00:07:57.319
program. Think about cell phone contacts.
The key would be the name of the person and

00:07:57.879 --> 00:08:04.119
the value would be the phone number, exact
same abstraction. Notice that we've been able

00:08:04.119 --> 00:08:09.629
to find three different examples that have
no relationship to each other whatsoever that

00:08:09.629 --> 00:08:15.699
all use exactly the same kind of logic. This
is great! This means if we write something

00:08:15.699 --> 00:08:21.270
for our environment variable class we may
be able to reuse it in a dictionary program

00:08:21.270 --> 00:08:27.240
and a cell phone contact program and probably
lots and lots of other programs. We'll talk

00:08:27.240 --> 00:08:33.659
about this more a little but later. What should
the design look like? Well the data are going

00:08:33.659 --> 00:08:39.550
to be pairs of String references so we have
to think about what the implementation possibilities

00:08:39.550 --> 00:08:45.620
are. Now we could use two ArrayLists in parallel
with matching indices being used to pair the

00:08:45.620 --> 00:08:51.569
data. So for example we'd have an ArrayList
that stores the keys, another ArrayList that

00:08:51.569 --> 00:08:56.040
stores the values, and we would know that
the key match the value if they were both

00:08:56.040 --> 00:09:03.040
at the same index. That's a possibility. We
also could have an ArrayList of StringPairs.

00:09:03.959 --> 00:09:07.850
Now at first this may seem a little more complicated
because if it's going to require us to do

00:09:07.850 --> 00:09:14.139
another class but think about the advantages.
The StringPairs will allow the key and value

00:09:14.139 --> 00:09:21.139
to be put together and then they can be put
in one ArrayList. That's a better design.

00:09:21.769 --> 00:09:26.920
There're also lots of other data structures
for this. In fact if you take a data structures

00:09:26.920 --> 00:09:32.470
class later, you're going to see all kinds
of interesting, clever, amazing ways of solving

00:09:32.470 --> 00:09:39.009
this problem. It's really a cool problem.
Now my choice here is going to be an ArrayList

00:09:39.009 --> 00:09:45.370
of StringPairs because eventually if we use
parallel arrays, they will get out of sync.

00:09:45.370 --> 00:09:50.190
It's just so hard to keep things like that
correct, ehereas with a single ArrayList things

00:09:50.190 --> 00:09:54.449
are never going to get out of sync. We're
never going to have a key shift to the next

00:09:54.449 --> 00:09:58.889
or the previous value because it's really
important to maintain the integrity of our

00:09:58.889 --> 00:10:05.889
data I think that's the best design. Now let's
design our StringPair class for data we're

00:10:06.449 --> 00:10:12.620
going to have two string a key and a value
and here are some methods. We'll have accessors

00:10:12.620 --> 00:10:19.620
for both fields, get key get value and a compare
to method. This will make things like sort

00:10:19.730 --> 00:10:25.079
and binary search possible to use later on.
Now I'm not actually going to use these in

00:10:25.079 --> 00:10:29.860
the program because the data here isn't big
enough to warrant them, but it might be handy

00:10:29.860 --> 00:10:34.569
later on when we move to those dictionary
and cell phone example classes. Of course

00:10:34.569 --> 00:10:40.589
we'll need a toString method. Now the thing
that I don't have here is mutators and there's

00:10:40.589 --> 00:10:45.670
reason for that. In general it's better to
make classes immutable. Well you'll say, "Well

00:10:45.670 --> 00:10:51.149
what if the key or the value changes?" Well
you know what we can construct a new StringPair.

00:10:51.149 --> 00:10:56.610
This isn't a large object and so reconstructing
it is just fine. That's really a much better

00:10:56.610 --> 00:11:01.920
design decision in many cases then creating
a bunch of mutators and making your class

00:11:01.920 --> 00:11:07.800
mutable. There are some very difficult debugging
problems that happen with mutable classes.

00:11:07.800 --> 00:11:13.279
So here's our design in UML. The StringPair,
the key and value in the data, notice I've

00:11:13.279 --> 00:11:17.879
made those private as you can see by the little
minus signs in front of them and then get

00:11:17.879 --> 00:11:23.449
key, get value, compared to and toString.
All of those are public as methods almost

00:11:23.449 --> 00:11:28.149
always are. Now notice I've done this the
way you usually do it in UML and I have not

00:11:28.149 --> 00:11:33.290
listed the constructors but we do need to
remember to write constructors in code. So

00:11:33.290 --> 00:11:37.860
if you're not comfortable with that make sure
you put your constructors in the UML so you

00:11:37.860 --> 00:11:42.300
don't forget them because that will cause
you problems writing your programs, particularly

00:11:42.300 --> 00:11:49.300
with immutable objects. Let's think about
the dictionary for a minute. Now we decided

00:11:49.350 --> 00:11:56.350
that our data would be an ArrayList of StringPair
and we're going to both accessor and mutators.

00:11:56.579 --> 00:12:01.540
Now this one definitely is going to need to
be mutable. So we need put, which we'll put

00:12:01.540 --> 00:12:08.540
a key value pair in and we need remove which
will remove a key value pair given just the

00:12:08.800 --> 00:12:15.800
key. We're also going to need an accessor
called getValue. That also takes the key but

00:12:16.259 --> 00:12:23.259
this one returns the value, which is a string
in this case. The issue that's important here

00:12:23.319 --> 00:12:28.329
is to remember that we need a complete set
of operations. This is absolutely critical

00:12:28.329 --> 00:12:35.029
for reuse. If we forget even one operation,
this class may not be reused and may not be

00:12:35.029 --> 00:12:40.589
used by other people. So the way you check
for that is to look and see - Do we have a

00:12:40.589 --> 00:12:46.500
way to find things, to add things, and to
remove things? And can anything and everything

00:12:46.500 --> 00:12:52.600
be found, added, and removed? Well if you
look for add you'll see that we have put,

00:12:52.600 --> 00:12:59.600
that's basically the add method. Find is get
value and remove of course is remove. So it

00:12:59.750 --> 00:13:06.170
looks like we've got our basic bases covered.
Now let's add some bells and whistles. We

00:13:06.170 --> 00:13:09.990
have to be really careful about this and I'll
talk a little bit more about the design decision

00:13:09.990 --> 00:13:16.990
I'm making here later. Do we need to be able
to access the size? Well one thing we certainly

00:13:17.699 --> 00:13:23.339
need to be able to access is isEmpty. That
is we need to know if there's anything stored

00:13:23.339 --> 00:13:29.220
in this dictionary or not. If there isn't
well then we probably shouldn't be doing search,

00:13:29.220 --> 00:13:34.209
so it turns out that's kind of an important
method. Now the question is - is it strictly

00:13:34.209 --> 00:13:39.079
necessary or is there a way we can work around
it? Well if you think about the methods we

00:13:39.079 --> 00:13:46.079
have right now, there isn't a workaround.
There's no way to tell from add, put, remove

00:13:46.600 --> 00:13:53.600
whether there's anything in the dictionary
or not. So isEmpty at this point is absolutely

00:13:54.310 --> 00:14:01.310
essential. It's a method we can't do without.
Now, let's think about another method. If

00:14:01.720 --> 00:14:08.019
you think about that contact list example
for cell phones well you know what? One thing

00:14:08.019 --> 00:14:12.300
we're going to need is a list of all the names
that are in the phone, because usually we're

00:14:12.300 --> 00:14:16.930
going to have a graphical user interface and
users are going to be picking those names.

00:14:16.930 --> 00:14:21.550
So we need a method that returns all of the
keys that are available. Now that will be

00:14:21.550 --> 00:14:28.550
an ArrayList of Strings. If we have that method
is isEmpty strictly necessary? Well, at that

00:14:30.370 --> 00:14:36.069
point it isn't and the reason is you can tell
if it's empty by calling the keys method.

00:14:36.069 --> 00:14:41.310
If the keys method returns an ArrayList of
String that's empty then we know that the

00:14:41.310 --> 00:14:47.699
dictionary is empty too. Now you have to be
careful here, because an isEmpty method is

00:14:47.699 --> 00:14:52.889
a pretty useful thing to have so I'm not saying
that you shouldn't have it but even without

00:14:52.889 --> 00:14:59.060
it as long as you have the keys method you
would still have a complete set of operations.

00:14:59.060 --> 00:15:03.019
These are the really tough design decisions
that you have to deal with as your programs

00:15:03.019 --> 00:15:09.860
get more complicated. So this design thing
turns out to be a balancing act. The problem

00:15:09.860 --> 00:15:15.870
is this: When classes are missing critical
methods they're impossible to reuse. Let's

00:15:15.870 --> 00:15:20.620
say for example that we didn't have the put
method there? Well at that point we can't

00:15:20.620 --> 00:15:25.399
add anything. Now that's kind of a silly example
because obviously it's useless without that,

00:15:25.399 --> 00:15:31.279
but for example remove methods frequently
are missing. Often there's a way to put things

00:15:31.279 --> 00:15:38.279
in but not take them out, and that can really
hurt reuse a lot. But then there's the other

00:15:38.449 --> 00:15:44.800
problem and that's that if a class gets too
big, if it gets too many methods in it, people

00:15:44.800 --> 00:15:49.149
tend not to use the class because they look
at it and they think, "Oh my God this is going

00:15:49.149 --> 00:15:54.230
to be so much work! It's going to be more
work than implementing it myself." Now I'm

00:15:54.230 --> 00:15:58.920
not very sympathetic to that point of view,
because it neglects the fact that that class

00:15:58.920 --> 00:16:04.149
that already exists has already been tested
and is probably working more correctly than

00:16:04.149 --> 00:16:09.209
one that's brand new will be working, but
this is something that people think. So for

00:16:09.209 --> 00:16:14.370
example when you're looking through the API
and you see an API page that has like twelve

00:16:14.370 --> 00:16:20.959
pages of methods on it the inclination to
decide to do something else is really strong.

00:16:20.959 --> 00:16:25.639
So this is the balancing act: you need to
provide enough operations so that you have

00:16:25.639 --> 00:16:30.629
a complete set, but not so many that people
give up on your class and decide to just do

00:16:30.629 --> 00:16:37.629
it themselves. It takes practice. So the need
for creating a comprehensive set of methods

00:16:39.600 --> 00:16:45.180
and keeping the class size manageable is what
needs to be balanced here. Now let's talk

00:16:45.180 --> 00:16:49.910
a little bit about the implementation. I'm
going to do a bottom-up implementation as

00:16:49.910 --> 00:16:54.129
I've mention that's one of my favorite ways
to do it. That means I'm going to create the

00:16:54.129 --> 00:16:59.579
StringPair class first. We're going to put
the data in the method in constructors in.

00:16:59.579 --> 00:17:04.809
Now I've put the method headers in just to
save us a little bit of time and I've also

00:17:04.809 --> 00:17:09.520
Javadoc'd it for you. These are things that
you would normally have to do yourselves.

00:17:09.520 --> 00:17:13.250
It's not very interesting to watch me do it
so I'm not going to do it in front of you

00:17:13.250 --> 00:17:19.680
but let's go to Eclipse and do the critical
parts of the code implementation. Here's our

00:17:19.680 --> 00:17:26.680
StringPair class. Now our instance data was
private string key and private string value.

00:17:34.030 --> 00:17:38.840
Here's our constructor. Now notice we only
have one constructor in this case, because

00:17:38.840 --> 00:17:44.260
this class is immutable we don't have any
chances for fixing mistakes we make, so all

00:17:44.260 --> 00:17:50.500
of the instance data must be correctly and
permanently initialized here. So our key is

00:17:50.500 --> 00:17:56.520
going to get the value of K and our value
is going to get the value of V. Now these

00:17:56.520 --> 00:18:01.660
single letter variable names are a little
bit obnoxious but if I put key and value there

00:18:01.660 --> 00:18:07.670
then we have to put the this's in. I guess
I can show you that on one of them...just

00:18:07.670 --> 00:18:14.670
so you know how to work around this problem.
So this.key = key. Remember this is the implicit

00:18:19.680 --> 00:18:25.960
object, that is, the object that's being used
to call this method. And so that's the way

00:18:25.960 --> 00:18:32.270
you work around that problem if you have it.
Now when you get key all we're going to do

00:18:32.270 --> 00:18:38.040
here is return key. So you probably noticed
that these little classes like this, these

00:18:38.040 --> 00:18:45.040
little immutable classes are extremely easy
to write. For getting the value, you return

00:18:47.030 --> 00:18:54.020
value. Now this one's a little bit more interesting,
because when we're making a comparison between

00:18:54.020 --> 00:18:59.580
two StringPairs we only want to compare the
key. Now there are a lot of ways this code

00:18:59.580 --> 00:19:06.580
can be written but there's a particular way
I like to write it. So we're going to have

00:19:07.620 --> 00:19:14.620
this.key so that's the key in the implicit
object.equals other.key, and we can return

00:19:18.470 --> 00:19:25.470
that. So we won't return false anymore of
course. Now that syntax may look a little

00:19:28.160 --> 00:19:33.640
bit scary to you. One way to make it look
a little bit more friendly is to put in another

00:19:33.640 --> 00:19:40.640
String object so let me show you that. And
then here, we'll make the comparison to the

00:19:46.800 --> 00:19:51.890
other key. Now if that makes it easier for
you to understand that's great, there's no

00:19:51.890 --> 00:19:58.820
shame in doing it this way. Obviously the
other way is little bit more concise. By the

00:19:58.820 --> 00:20:04.750
way - one thing to notice about equals objects.
When I created the equals method in the StringPair

00:20:04.750 --> 00:20:11.520
class I relied on the equals method in the
String class. That's actually really typical,

00:20:11.520 --> 00:20:16.770
equals methods tend to call other equals methods
compare to methods tend to call other compare

00:20:16.770 --> 00:20:22.840
to methods and constructors also tend to call
other constructors. And so keep that in mind

00:20:22.840 --> 00:20:26.830
when you're implementing these things, because
often there's a method already available that

00:20:26.830 --> 00:20:32.370
can do most of the work for you. Compare to
is another example of this, because we're

00:20:32.370 --> 00:20:39.370
going to just be comparing keys. Well, this
is really easy. In fact we're going to do

00:20:39.430 --> 00:20:46.430
this.key.compare to other.key. Now this is
the same syntax that I did the first time

00:20:47.920 --> 00:20:53.080
in the equals class. If you like the other
syntax you can modify it and put it in but

00:20:53.080 --> 00:20:58.520
I'll leave both examples here so you'll have
them both to work from and here's our to String

00:20:58.520 --> 00:21:05.520
method. Of course as always we'll put in some
Strings. Now this to String method is probably

00:21:15.380 --> 00:21:19.540
going to be used more for debugging than anything
else, but it's kind of nice to have one of

00:21:19.540 --> 00:21:24.800
those around. It can make debugging a lot
easier if things get tricky. Now of course

00:21:24.800 --> 00:21:29.430
at this point you probably should be testing
this method. As has become a bad habit lately

00:21:29.430 --> 00:21:33.160
I'm not actually going to do the testing in
front of you just to save us a little bit

00:21:33.160 --> 00:21:39.690
of time, but remember test often, test early,
test small bits of code before you put them

00:21:39.690 --> 00:21:45.510
into big bits of code. You'll have a much
more pleasant programming life. So now that

00:21:45.510 --> 00:21:49.650
we've created the StringPair class the next
thing we're going to do is to create the dictionary

00:21:49.650 --> 00:21:56.570
class. So we'll need to create the data, the
constructor, and the methods. So here's our

00:21:56.570 --> 00:22:03.570
dictionary class. Notice our ArrayList has
been imported and right here is our instance

00:22:03.760 --> 00:22:10.760
data. It's an ArrayList of StringPairs and
we've called it dictionary. This is our constructor,

00:22:10.850 --> 00:22:16.200
remember, the goal of a constructor is to
set up the instance data. So what we say is

00:22:16.200 --> 00:22:23.200
dictionary is new ArrayList of StringPair
because we have only one element of instance

00:22:26.110 --> 00:22:31.640
data, well, that means we only have one thing
that we have to initialize in the constructor.

00:22:31.640 --> 00:22:37.350
As a general rule, if you have X elements
of instance data there should be X things

00:22:37.350 --> 00:22:42.320
initialized in your constructor. And even
if there's a case where that isn't true, you

00:22:42.320 --> 00:22:46.000
always want to check and make sure that it's
okay that that hasn't been initialized, but

00:22:46.000 --> 00:22:52.280
it isn't going to break your class. Now here
we need to insert a new key and value into

00:22:52.280 --> 00:22:58.040
the dictionary. Well that's sort of interesting
because the dictionary has a StringPair in

00:22:58.040 --> 00:23:05.040
it. So first we need to create a StringPair
and I'll call it element. We know we construct

00:23:09.290 --> 00:23:16.290
a StringPair by using key and value and then
this is what gets added into our dictionary.

00:23:16.770 --> 00:23:22.720
Remember dictionary is just an ArrayList and
so we use the add method just like we do with

00:23:22.720 --> 00:23:29.570
any other ArrayList. Well that's kind of nice,
but now the question is are we able to actually

00:23:29.570 --> 00:23:35.620
keep our promises if we do this? Remember
that keys were supposed to be unique and we

00:23:35.620 --> 00:23:40.350
didn't do any checking before we did this
insertion to make sure they were unique. So

00:23:40.350 --> 00:23:45.540
we really need to think that through. In particular,
this is something that is going to come up

00:23:45.540 --> 00:23:51.890
a lot of different times-- even with the remove
method. So what would be nice is to look through

00:23:51.890 --> 00:23:58.890
the dictionary and see if this key is already
in there. Now that is so necessary so many

00:24:00.740 --> 00:24:06.080
times that it really deserves its own little
private method. Now this is something we didn't

00:24:06.080 --> 00:24:13.080
anticipate in our design and that's fine.
I called it findKeyIndex. Now notice I made

00:24:13.190 --> 00:24:18.150
this method private and it's really important
that this be private. Notice that this refers

00:24:18.150 --> 00:24:24.390
to an index. No place else in the interface
to our dictionary did we use the word index

00:24:24.390 --> 00:24:29.370
at all. In other words somebody looking at
our dictionary class doesn't know that there's

00:24:29.370 --> 00:24:34.090
an ArrayList hidden in here. This is good
encapsulation. This is the way design is supposed

00:24:34.090 --> 00:24:40.540
to be done. So when I called this method with
the word index that means it has to be private

00:24:40.540 --> 00:24:47.260
to keep our secret that there's an ArrayList
hiding around in here. Now you might think

00:24:47.260 --> 00:24:52.640
we could use something like contains but we've
got a problem there. Contains relies on an

00:24:52.640 --> 00:24:57.710
equal method to be available. You might think
we could use binary search, but remember we

00:24:57.710 --> 00:25:02.580
didn't keep our ArrayList in sorted order.
It turns out that in Java there are some touchy

00:25:02.580 --> 00:25:06.920
things about being able to get this to all
work out and we're not really ready to do

00:25:06.920 --> 00:25:12.460
them, so we're just going to have to use a
plain linear search here. So we're going to

00:25:12.460 --> 00:25:18.960
do a for loop. I think I'll do a for each
loop because I think that makes sense. Oh

00:25:18.960 --> 00:25:23.900
wait a minute though, because I had to return
an index a for each loop doesn't make sense,

00:25:23.900 --> 00:25:30.900
remember, for each loops don't have access
to the index. So let's say index is zero,

00:25:31.210 --> 00:25:38.210
index is less than dictionary.length ++ index.
If key equals well, let's think about what

00:25:45.660 --> 00:25:52.660
we want it to equal. We're going to have a
StringPair the comes back from dictionary.get

00:25:55.390 --> 00:26:02.390
of index. So that's a nice little pair, but
we're only going to compare to the first element.

00:26:03.500 --> 00:26:10.500
So let's create a string which I'll call first
and that's going to be pair.getkey. Now you

00:26:14.770 --> 00:26:19.270
can put all this stuff in one line but it
tends to get kind of confusing, whereas if

00:26:19.270 --> 00:26:23.590
you separate it out into different lines you
can really think carefully about what type

00:26:23.590 --> 00:26:29.170
of object is being returned. So for example
when we call dictionary.get, we know that

00:26:29.170 --> 00:26:36.170
our dictionary has StringPair objects in it
and so a StringPair is what gets returned.

00:26:40.560 --> 00:26:47.560
If the key equals first, then we return the
index. Now if we get to the end of that for

00:26:47.590 --> 00:26:54.590
loop and we haven't found anything, that's
when we return -1. Oh! And I see I made a

00:26:56.190 --> 00:27:03.190
mistake here. I've been programming too much
with arrays, I forgot that because dictionary

00:27:03.630 --> 00:27:09.130
is an ArrayList instead of an array you use
the size method instead of using the linked

00:27:09.130 --> 00:27:16.130
data. So there we go we've got our find key
index method. So now we can go back and deal

00:27:16.510 --> 00:27:23.510
with our put method. So if findKeyIndex of
key is not equal to -1, well let's think about

00:27:37.650 --> 00:27:44.650
what happens in that case. That means there's
already a key in here that has that index.

00:27:45.480 --> 00:27:51.380
Well in that case we're not going to put a
second key in, so we should just return. Now

00:27:51.380 --> 00:27:55.160
you could make a different decision than that.
You could decide to remove that first key

00:27:55.160 --> 00:28:00.190
and put the second one in, that would be fine.
Really the thing that's important is that

00:28:00.190 --> 00:28:05.620
it's correctly documented right here in the
Javadoc because if it isn't there than people

00:28:05.620 --> 00:28:12.620
won't know about it and they'll get confused.
Okay, so let's think about remove. Well that's

00:28:12.640 --> 00:28:18.020
going to give us another opportunity to use
our little method we just wrote. So if find

00:28:18.020 --> 00:28:25.020
key index of key equals -1, well that means
that that key wasn't found. Well if it isn't,

00:28:29.890 --> 00:28:36.360
if we don't have the key we can't move it,
so we should just return and otherwise we

00:28:36.360 --> 00:28:43.360
should do dictionary.remove at index. So notice
we're letting the ArrayList class don an awful

00:28:46.040 --> 00:28:53.040
lot of the work for us. Whoops! I see that
I forgot to save this at an index, so let's

00:28:53.040 --> 00:29:00.040
improve this code a little bit. So now I'm
saving it to a variable name then I'm checking

00:29:01.670 --> 00:29:08.670
to see if that variable is -1 and then removing
the index at the end. When we need to get

00:29:12.350 --> 00:29:19.280
a value for the string key, guess what? We
can use our same method again. So here we're

00:29:19.280 --> 00:29:26.280
going to have int index is findKeyIndex of
key. Now we need to think this through carefully,

00:29:36.960 --> 00:29:43.960
because when we do a get from the dictionary
that's going to return a StringPair object

00:29:47.230 --> 00:29:54.230
and we're trying to find its value. So what
we're going to return is pair.get value. Once

00:29:54.690 --> 00:30:00.180
again because pair is a StringPair object,
that means only the methods in the StringPair

00:30:00.180 --> 00:30:05.090
class are going to be accessible to us, those
are the only things that are going to work.

00:30:05.090 --> 00:30:08.840
So you'll notice when you start to get more
classes in your programs it becomes really

00:30:08.840 --> 00:30:15.140
important to remember exactly what type each
object is and usually declaring a few more

00:30:15.140 --> 00:30:20.660
variable names will really help that out.
Now I'm not going to leave all that ugly empty

00:30:20.660 --> 00:30:26.790
space in there. So there's our nice little
findKeyIndex, which notice we've reused already

00:30:26.790 --> 00:30:33.790
three times! That's kind of cool. isEmpty
comes directly from the dictionary class,

00:30:33.920 --> 00:30:38.940
so we're letting it do the hard work and here's
the keys method. Let me go through that one

00:30:38.940 --> 00:30:44.760
with you for a minute. First I created an
ArrayList of Strings called Results and constructed

00:30:44.760 --> 00:30:50.010
it, so it's initially empty. Then I went through
the StringPairs in the dictionary one at a

00:30:50.010 --> 00:30:56.690
time and put the key into the ArrayList of
Strings and that's what gets returned at the

00:30:56.690 --> 00:31:03.690
end. Nice way to do it. So now we've implemented
the StringPair class and the dictionary class.

00:31:07.250 --> 00:31:11.620
The last thing that's left to do is to create
the driver. So let's think for a minute about

00:31:11.620 --> 00:31:17.250
what our driver should do. Well we should
read the configuration file. Now I'm going

00:31:17.250 --> 00:31:22.190
to show you a trick with the configuration
file that you haven't seen before I suspect,

00:31:22.190 --> 00:31:26.190
and that's a we're going to use a command
line argument. Now there are a couple of reasons

00:31:26.190 --> 00:31:30.710
I'm doing this one is that it's some kind
of cool programming. We've been putting in

00:31:30.710 --> 00:31:35.000
that string square bracket args thing all
semester and we really haven't used it for

00:31:35.000 --> 00:31:39.790
anything, so I thought it might be nice for
you to see it in action. In order for this

00:31:39.790 --> 00:31:45.580
to work we need to create that name of the
file in Project, Properties, Run and Debug

00:31:45.580 --> 00:31:51.600
Settings just where we went before, only we're
going to go to program arguments and we'll

00:31:51.600 --> 00:31:58.600
put the filename in the box. So let me show
you where that is. So Project, Properties,

00:32:00.100 --> 00:32:06.240
here are our Run and Debug Settings so this
is what we're going to edit, and here are

00:32:06.240 --> 00:32:13.240
the arguments. So the program arguments remember
we decided to call it or I decided I guess,

00:32:13.310 --> 00:32:20.310
I don't think you really had a voice in it,
bashrc.txt. So that's okay and that's okay.

00:32:24.160 --> 00:32:29.990
So that way we now have this in our method.
Now if you're wondering where it got the name

00:32:29.990 --> 00:32:35.620
of a command line argument, when you don't
call programs inside of Eclipse like we usually

00:32:35.620 --> 00:32:40.980
do you call them from that little Terminal
thing and that Terminal is called a command

00:32:40.980 --> 00:32:45.570
line. And the way a command line works is
first you give the name of the program and

00:32:45.570 --> 00:32:50.600
then a space and then the name of the file,
so that's where it got its name from. So that

00:32:50.600 --> 00:32:56.510
should be a kind of a fun thing to do. Let's
go to our driver class and put that in. Well,

00:32:56.510 --> 00:33:03.510
the first thing we need to do is to make sure
that we can get it from the arguments. If

00:33:06.850 --> 00:33:13.850
args.length is 0, well we need to think of
what we're going to do in this case. If args.length

00:33:15.380 --> 00:33:21.550
is 0, remember args is a String Array you
can see that right up here in line 18, what

00:33:21.550 --> 00:33:27.110
that means is we didn't get our command line
argument that's kind of a problem. So we probably

00:33:27.110 --> 00:33:34.110
want to tell the user about that. So no configuration
file was found. Now you need to decide whether

00:33:39.140 --> 00:33:43.950
we should quit the program at this point or
go on. Since it is possible to continue without

00:33:43.950 --> 00:33:48.530
a configuration file, I'm not going to quit
the program but that is another option that's

00:33:48.530 --> 00:33:55.400
available. Now if args length isn't 0 then
we're hoping it's 1. So we're going to have

00:33:55.400 --> 00:34:02.400
then else String filename equals args of 0.
So the first command line argument there's

00:34:09.250 --> 00:34:16.250
only one in this case args of 0 because arrays
are zero indexed goes into the filename. Now

00:34:18.860 --> 00:34:24.230
once we have the filename, then we need to
read the file. So let's take a look at our

00:34:24.230 --> 00:34:29.580
read file method. It's going to take a filename
and it's going to take a dictionary object

00:34:29.580 --> 00:34:36.580
which I've called env, so we're going to have
to implement that method. We've been reading

00:34:36.740 --> 00:34:43.740
files with scanners 
so you're certainly familiar with that line
of code. Looks like I've gotten inordinately

00:34:53.500 --> 00:35:00.500
fond of n's, so let's fix the spelling there.
As always with reading a file, while file.has

00:35:02.620 --> 00:35:09.620
next line so we'll have a String line is file.next
line and then we need to take that line and

00:35:17.010 --> 00:35:22.020
add it into the dictionary. Now you may have
noticed that over the top of this method is

00:35:22.020 --> 00:35:26.990
a method called addToDictionary, so we're
going to have to deal with that method eventually

00:35:26.990 --> 00:35:33.990
but we can use it now even though we haven't
written it yet. So we'll do add to dictionary,

00:35:34.610 --> 00:35:41.610
the line at env and of course the last thing
we want to do is to close the file so that

00:35:46.350 --> 00:35:52.520
we don't have Eclipse unhappy with us. Now
we need to deal with that add to dictionary.

00:35:52.520 --> 00:35:58.510
Remember the format of lines in the file is
key equals value. So we can actually use that

00:35:58.510 --> 00:36:05.510
equal sign to our advantage to pull things
apart, so let's do that. We've got our line

00:36:08.080 --> 00:36:12.380
so we're going to I have a String called key
and we're going to get that as the part of

00:36:12.380 --> 00:36:19.380
the String line that comes before the equals
sign. So the way you find that, I'll call

00:36:22.650 --> 00:36:29.650
it index equals we're going to take line and
then find the index of the equals. Now one

00:36:35.040 --> 00:36:39.480
thing that will tell us is whether we even
have an equals sign in the line. If we don't

00:36:39.480 --> 00:36:46.480
have an equals sign we don't want to be entering
it as a value. So if index equals equals -1,

00:36:50.330 --> 00:36:54.970
which is the value that gets returned if it
isn't found then what we should do is just

00:36:54.970 --> 00:37:01.070
return, that is, get out of here. And it's
not a bad idea to make a little comment there

00:37:01.070 --> 00:37:08.070
to let people know what's going on. If there
is no equals sign, there is no key value pair,

00:37:12.790 --> 00:37:19.790
add nothing to the dictionary. Now if it's
not equal to -1 that means that we've found

00:37:24.470 --> 00:37:31.470
the equals sign so the key then is line.substring
starting at 0 and going to index of. Now we

00:37:35.570 --> 00:37:42.570
haven't to used substring in a while I'm sorry,
index equals. There's a quirk to substring

00:37:43.510 --> 00:37:49.840
that you may not remember because we haven't
used it in a while. That first index is inclusive

00:37:49.840 --> 00:37:56.800
and the second index is exclusive. So what
that means is 0 is included and index equals

00:37:56.800 --> 00:38:02.850
is excluded, so notice that works really,
really well for this particular case. In fact

00:38:02.850 --> 00:38:07.960
this is one of the reasons that substring
is written that way. We also need to get out

00:38:07.960 --> 00:38:14.960
our value. Now here we're going to do line.substring
well we need to start at index equals +1 and

00:38:21.390 --> 00:38:28.390
we need to end at the end, which is line.length.
One thing to remember here is that line itself

00:38:32.640 --> 00:38:38.100
is a String and as such it's immutable, so
when we're creating these substrings key and

00:38:38.100 --> 00:38:42.940
value are actually new substrings they're
not part of line at all. So there's no danger

00:38:42.940 --> 00:38:48.600
in this, we haven't damaged line. At this
point we're now ready to add these into the

00:38:48.600 --> 00:38:55.600
dictionary so we'll do env. and we need to
remember the name of our add method, so we

00:38:58.180 --> 00:39:05.180
can go look it up over here. So we called
it put and it takes two String arguments which

00:39:05.640 --> 00:39:12.290
are the key and the value. So notice this
class does not know about the StringPair class

00:39:12.290 --> 00:39:17.870
at all. That's kind of nice. It makes it easier
not having to wrestle with more classes in

00:39:17.870 --> 00:39:23.080
here just being able to let the dictionary
do the work. This is where good design really

00:39:23.080 --> 00:39:30.080
pays off. Okay, so let's go back to our main
program. So we created our dictionary, we've

00:39:35.200 --> 00:39:41.050
got a scanner to interact with the user, if
there's no configuration file we didn't do

00:39:41.050 --> 00:39:47.430
anything, if there was a configuration file
we got the file name and then we called or

00:39:47.430 --> 00:39:54.430
we should call read file with the filename
and environment, our dictionary. So that gets

00:39:59.500 --> 00:40:05.850
some data read into our environment file.
Now I've got an infinite loop here and notice

00:40:05.850 --> 00:40:12.340
I've marked that it's infinite on purpose,
so we print line enter the variable name to

00:40:12.340 --> 00:40:18.460
see the environment variable or variable equals
value to add a new one or quit to exit. So

00:40:18.460 --> 00:40:24.000
then we read in the line from the keyboard,
if it equals quit we just exit remember we

00:40:24.000 --> 00:40:29.950
don't save the file here. That was really
critical. If it has an equals, if the line

00:40:29.950 --> 00:40:36.270
contains equals, then that's when we add it
to the environment. Well we have a method

00:40:36.270 --> 00:40:43.270
for that now - it's environment.addTo dictionary.
It takes the line first...whoops! And it's

00:40:54.530 --> 00:41:01.530
not environment.addTo dictionary. Environment
is passed as a parameter. Now otherwise, well

00:41:06.760 --> 00:41:11.800
in that case we have variable equals value,
and guess what? We've already added a method

00:41:11.800 --> 00:41:18.800
to deal with that. That is add to...I'm sorry,
we don't have a method to deal with that.

00:41:19.110 --> 00:41:23.080
That's not adding to the dictionary, so our
other case which maybe I'd better put a comment

00:41:23.080 --> 00:41:27.869
in to help us out here is do a search. Well
I guess I already have a comment on that if

00:41:27.869 --> 00:41:34.869
I would just read it. So to do a search, we're
going to do environment.getValue for line.

00:41:48.090 --> 00:41:54.960
So notice in this case we're pushing the work
off into the dictionary class. Well that's

00:41:54.960 --> 00:41:58.770
our main program, so I guess it's time to
do a little bit of testing and hope for the

00:41:58.770 --> 00:42:03.130
best. Now we've written an awful lot of lines
of code without testing anything. Let's hope

00:42:03.130 --> 00:42:10.130
we don't pay for that decision shortly. So
no configuration file was found. That's not

00:42:13.930 --> 00:42:20.930
a good thing. Now we can see I have a bashrc.txt
and it was all in little letters, probably

00:42:21.960 --> 00:42:26.610
a good time to check our environment variables
and see if I put it all in little letters

00:42:26.610 --> 00:42:33.610
too there. So we go to our properties. Now
that's interesting, I wonder if this is what

00:42:36.890 --> 00:42:43.170
the problem. It seems to have several different
configurations, so let's delete those configurations

00:42:43.170 --> 00:42:50.170
and just work with one. Let's edit that configuration.
So we're looking at the arguments, it's bashrc.txt

00:42:50.380 --> 00:42:57.380
and it's all in little letters, so that looks
okay. Now remember I did remove those other

00:42:58.710 --> 00:43:03.610
two configurations so I have changed something.
So let's rerun the program again and see if

00:43:03.610 --> 00:43:10.540
things are behaving better. No, it still didn't
find our configuration file. Hmmm, so that's

00:43:10.540 --> 00:43:17.540
a problem. Well let's make sure it's in the
right place. So here's our environment variables

00:43:18.480 --> 00:43:24.740
and here's our bashrc.txt. Now this is the
data I cut and pasted it from the Terminal

00:43:24.740 --> 00:43:31.740
window, so that looks good. So we still have
a little bit of debugging to do so let's think

00:43:38.410 --> 00:43:44.550
a little bit about this. So args.length has
to be coming in as 0, so somehow it's not

00:43:44.550 --> 00:43:51.550
finding our command line arguments. So let's
go and take one more look. Well now that's

00:43:52.450 --> 00:43:59.450
interesting, it reset them for us. Well that
is probably a problem. So let's go edit that

00:43:59.740 --> 00:44:06.740
one and see if we have our yeah...so as you
can see these command line arguments are a

00:44:09.240 --> 00:44:16.240
little bit complicated to deal with inside
of Eclipse. Let's see if we got them now.

00:44:17.190 --> 00:44:21.970
Ah good! So it found our file at this point
that's a good thing. Don't let that scare

00:44:21.970 --> 00:44:26.190
you away from using command line arguments,
they're actually really handy in a lot of

00:44:26.190 --> 00:44:31.450
cases. Probably not a bad idea to look and
see what some of the variables are so we have

00:44:31.450 --> 00:44:36.490
one that's called groups it's just a couple
of parentheses. We've got histsize that should

00:44:36.490 --> 00:44:43.490
be 500. So let's look at this. Hmmm, so that's
interesting it didn't find groups. It didn't

00:44:50.730 --> 00:44:57.730
find histfile let's try adding something and
see if that works. So let's say histfile = 300

00:45:02.910 --> 00:45:09.910
and then histfile. Hmmm, something isn't working
very well so it's time to go back to our driver

00:45:12.630 --> 00:45:19.430
and see what went wrong. So first we see if
the name equals quit. By the way notice that

00:45:19.430 --> 00:45:25.990
quit was working, so we know that's okay.
Now if the line contains equal then we add

00:45:25.990 --> 00:45:32.990
the line to the environment. Hmmm, that looks
good and otherwise we get value from the line.

00:45:36.040 --> 00:45:41.790
Well that looks good too, so let's take a
look and see what's happening here. So we

00:45:41.790 --> 00:45:48.790
have our index equals is the index of the
equals that looks correct. If index equals

00:45:49.030 --> 00:45:55.360
is -1 that is, if it's not found, then we
should just return. Then we pull out the two

00:45:55.360 --> 00:46:02.360
pieces and put it into the dictionary. Hmmm,
that looks pretty good. Let's see if something

00:46:03.980 --> 00:46:10.410
went wrong here. Now notice both of our things
are going wrong at this point that is both

00:46:10.410 --> 00:46:15.230
reading from the file and the search were
going wrong, adding things in at the command

00:46:15.230 --> 00:46:20.730
line was going wrong, so the problem is almost
certainly an addToDictionary even though it

00:46:20.730 --> 00:46:26.720
looks good. So let's think about where things
could go wrong well one thing that could go

00:46:26.720 --> 00:46:31.610
wrong is maybe I didn't remember how index
of worked correctly. Let's go to the API and

00:46:31.610 --> 00:46:38.610
take a look. Here's our String class and we're
looking for the index of method remember,

00:47:02.960 --> 00:47:09.960
they're in alphabetical order. So we use with
the one with a String so it returns the index

00:47:11.480 --> 00:47:17.190
within the String at the first occurrence
of the specified substring. The return index

00:47:17.190 --> 00:47:23.700
is the smallest value of k. If there's no
such value then -1 is returned. Okay, so the

00:47:23.700 --> 00:47:30.700
right thing is returned there. So that's kind
of funny. So I guess it's time to pull out

00:47:40.109 --> 00:47:47.109
some of our better debugging tools. Let's
go over to debug mode 
and think about where we want to be when we

00:47:56.510 --> 00:48:03.510
check. I think right about here is a good
place to check. If we stop here we'll be able

00:48:08.480 --> 00:48:15.480
to see what both key and value are and that
will be very useful for us. So let's run the

00:48:15.890 --> 00:48:22.890
program now in debug mode remember, when you
run in debug mode you use the little bug icon.

00:48:23.940 --> 00:48:30.940
So we're right there and let's look and see
what key and value are so key is bash and

00:48:31.160 --> 00:48:38.160
value is that, so key and value look like
good things. So then we're doing env.put.

00:48:39.270 --> 00:48:46.270
Well now this makes me wonder if maybe we
didn't do that put method correctly, but let's

00:48:46.350 --> 00:48:51.090
keep going a couple more times and see if
we get the right thing. So here's the next

00:48:51.090 --> 00:48:58.090
one bashargc and that's and 0 and here's the
next one. So now we're stepping through the

00:48:58.970 --> 00:49:05.970
lines in the file 
and notice those all seem to be coming correctly
now I say this based on the yellow columns

00:49:11.660 --> 00:49:17.270
over here, so it looks to me like that put
method is the one we should be suspicious

00:49:17.270 --> 00:49:24.270
of. Now the put method is in the dictionary
class, so let's go and look at the dictionary

00:49:24.270 --> 00:49:31.270
class and see what happened with that. So
here's the put method, so if find key index

00:49:34.550 --> 00:49:41.310
is not equal to -1, so let's think about that
for a minute. If we're putting it in there

00:49:41.310 --> 00:49:48.310
we don't want to find the key already. So
when the key is -1 we want it to be successful.

00:49:51.810 --> 00:49:58.810
So I think that maybe we could rewrite this
logic a little bit better if we wrote it like

00:50:00.100 --> 00:50:07.100
this: that is, if it isn't found, that's when
we want to put in, so that makes sense. So

00:50:12.500 --> 00:50:19.230
we created our new StringPair and then we
did a dictionary.add. Dictionary.add should

00:50:19.230 --> 00:50:24.910
be working fine. I wonder if our find key
index is working well. So let's take another

00:50:24.910 --> 00:50:31.340
look at that method too while we're here.
So we started at 0, we check to see if index

00:50:31.340 --> 00:50:37.660
is less than the size and then incremented
it that looks good. So we get the pair from

00:50:37.660 --> 00:50:44.660
that index, we find the first element, and
then we see if the key that's the one that

00:50:45.400 --> 00:50:52.400
was passed in as the parameter, equals first.
If it is equal we return index and only when

00:50:53.140 --> 00:50:58.340
we get to the end when it's not equal do we
return -1. Well you know what? That looks

00:50:58.340 --> 00:51:03.080
pretty good too, but maybe we need to step
through that line at a time, that may be our

00:51:03.080 --> 00:51:09.609
next target. Let's actually check and make
sure things are still behaving the same way

00:51:09.609 --> 00:51:15.930
as we gather more information about how our
program is working. So let's look for bash

00:51:15.930 --> 00:51:22.930
because we saw that one added in. You know...I
have a thought. I don't know if we gave the

00:51:25.470 --> 00:51:31.160
user any feedback in our driver. In other
words this might just be a silly driver mistake.

00:51:31.160 --> 00:51:38.160
Let's take a look at that and see what's happening
again. Aha! Well look at that. I got this,

00:51:38.770 --> 00:51:45.770
but I didn't show it to the user. So this
is really foolishness going on here. So if

00:51:48.359 --> 00:51:55.359
we do a search, well, what we want to do is
actually print this out-- 
otherwise we don't know if our search has

00:52:02.950 --> 00:52:09.950
been successful or not. Now when things get
added, we might think about whether we went

00:52:11.340 --> 00:52:15.660
to print something out to say whether it's
successful or not, because we can tell from

00:52:15.660 --> 00:52:22.660
the search we probably don't have to. Let's
run our program again and see if things are

00:52:22.760 --> 00:52:28.790
making more sense now. Now I'm going to change
over to our bashrc.txt file so we can check

00:52:28.790 --> 00:52:35.790
for things. So let's check for bash. Ahhh,
that's looking better! So euid501 hostname

00:52:40.590 --> 00:52:47.230
notice this is the last one. That one looks
good so I've checked the first, the middle,

00:52:47.230 --> 00:52:54.230
and last. Now we need to add one in, so let's
say path equals userlib and then we're going

00:52:57.700 --> 00:53:03.970
to search for path and we get userlib. Well
oh yes, we were going to check that again

00:53:03.970 --> 00:53:10.970
remember for the first, middle, and the last
just to make sure we hadn't overwritten anything

00:53:13.880 --> 00:53:19.480
and that's still correct. So now it looks
like our program is working. Well that was

00:53:19.480 --> 00:53:23.850
some silly stuff but at least you got to see
the debugger used a little bit more, so that's

00:53:23.850 --> 00:53:29.000
always good. Now we have something really
profound that happened in this program that

00:53:29.000 --> 00:53:34.300
I want to bring to your attention. We actually
used a very advanced design technique. It's

00:53:34.300 --> 00:53:39.369
something that's called a façade. Design
patterns are really cool part of computer

00:53:39.369 --> 00:53:43.890
science. You aren't going to be able to study
them very comprehensively too soon because

00:53:43.890 --> 00:53:47.770
they're kind of advanced, but on the other
hand I want you to point out that this is

00:53:47.770 --> 00:53:53.190
something that we've used. If you think about
what a façade is it's a fake front and that's

00:53:53.190 --> 00:53:59.840
basically what we did at our dictionary class.
So the work behind the scene is all ArrayList

00:53:59.840 --> 00:54:05.240
but the dictionary itself looks like something
very different, so this is kind of a neat

00:54:05.240 --> 00:54:11.420
trick. So what we did was hide the interior
workings of the class from the world. So for

00:54:11.420 --> 00:54:16.900
example notice how carefully I concealed the
index. The index is the thing that gives it

00:54:16.900 --> 00:54:21.840
away that tells us that it's an array and
so I kept the only method that used an index

00:54:21.840 --> 00:54:28.460
private so the exterior world couldn't see
it. It's really good programming. Now this

00:54:28.460 --> 00:54:32.660
trick is something you use when you have to
do something quick and dirty. So maybe your

00:54:32.660 --> 00:54:37.390
boss or your company needs something right
now, and your intention is to go back and

00:54:37.390 --> 00:54:42.849
put in something much more elegant and beautiful.
For example, it would really have been nice

00:54:42.849 --> 00:54:47.970
if we'd sorted our ArrayList than we could
have used binary search on it. These are really

00:54:47.970 --> 00:54:53.550
important things in terms of efficiency. One
thing I will say about the façade design

00:54:53.550 --> 00:54:58.050
pattern though is that there's a saying in
computer science that there's never time to

00:54:58.050 --> 00:55:02.300
do it right but there's always time to do
it over, so you have to do careful about doing

00:55:02.300 --> 00:55:08.500
this too often. It can be really hard to get
the time to go back and fix things like this

00:55:08.500 --> 00:55:13.330
and also make sure that when you do it that
you are actually documenting it well so that

00:55:13.330 --> 00:55:17.849
somebody else can see that this is something
that needs to be done, that will help you

00:55:17.849 --> 00:55:24.510
remember. One of those little to do comments
in Eclipse is one of the ways of doing that.

00:55:24.510 --> 00:55:30.869
Now let's talk about the Java API. Believe
it or not the Java API already has classes

00:55:30.869 --> 00:55:36.490
for this. And wouldn't you know it the name
of the class is dictionary! Now when you're

00:55:36.490 --> 00:55:41.130
new to Java programming knowing all these
class names is virtually impossible. This

00:55:41.130 --> 00:55:46.090
is something that progresses as you become
more and more familiar with the language.

00:55:46.090 --> 00:55:51.160
Also the dictionary class is deprecated. We
talked about deprecation a little bit earlier

00:55:51.160 --> 00:55:57.470
in the semester. What it means is that there's
an implied threat that the dictionary class

00:55:57.470 --> 00:56:01.930
is going to be removed in the next version.
Now the dictionary's been deprecated for quite

00:56:01.930 --> 00:56:07.740
a while so once again, I actually don't believe
Java's implied threats, but that's also a

00:56:07.740 --> 00:56:14.140
way of the API people telling you that this
isn't the right class to use. This is an old-fashioned

00:56:14.140 --> 00:56:18.390
one we've left it around because people have
used it but really in the future you need

00:56:18.390 --> 00:56:24.170
to use something else. Now it turns out this
class looks exactly like what we designed

00:56:24.170 --> 00:56:29.420
except for a couple things. One is that it
uses generics just like our ArrayList class

00:56:29.420 --> 00:56:36.420
does, so while we created one that has to
strings this one you could use any to classes.

00:56:36.920 --> 00:56:40.930
The other thing is the keys method returns
something called an enumeration instead of

00:56:40.930 --> 00:56:45.880
an ArrayList. Enumerations are kind of cool,
they're one of the ways that you step through

00:56:45.880 --> 00:56:51.720
things but it's not a technique we've done
and so we really couldn't do that. Also there

00:56:51.720 --> 00:56:55.720
are two additional methods that we didn't
implement. This is where the completeness

00:56:55.720 --> 00:57:01.369
thing comes in again. One is called values.
So just like we had a method that returned

00:57:01.369 --> 00:57:06.260
all of the possible keys in an ArrayList,
we can have a method that returns all of the

00:57:06.260 --> 00:57:12.910
possible values. In this case it would return
them as an enumeration. Now there's also a

00:57:12.910 --> 00:57:18.030
size method that returns the number of key
value pairs. I've never really understood

00:57:18.030 --> 00:57:23.450
exactly why the size method is necessary,
but maybe there's some situation that it is

00:57:23.450 --> 00:57:30.369
necessary and that I haven't encountered yet.
It turns out the class in the API that replaced

00:57:30.369 --> 00:57:35.890
dictionary is something called map. Map is
an amazingly wonderful, cool class that's

00:57:35.890 --> 00:57:41.590
used all over the place. It's part of the
Java collections framework just ArrayList

00:57:41.590 --> 00:57:46.230
is, but it's a little more complicated class.
You're going to study than in more advanced

00:57:46.230 --> 00:57:53.230
programming courses, for example the CS 2334
class at the University of Oklahoma. So keep

00:57:54.810 --> 00:57:55.240
programming!

