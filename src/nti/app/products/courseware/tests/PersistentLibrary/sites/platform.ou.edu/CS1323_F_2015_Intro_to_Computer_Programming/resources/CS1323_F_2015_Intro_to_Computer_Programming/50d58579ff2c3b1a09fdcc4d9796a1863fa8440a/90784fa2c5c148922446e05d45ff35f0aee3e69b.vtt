WEBVTT
Kind: captions
Language: en

00:00:01.069 --> 00:00:06.210
&gt;&gt;Let's continue our study of encapsulation
by completing the implementation of our Frogger

00:00:06.210 --> 00:00:12.160
game. Here's our problem statement: Let's
continue the development of the Frogger game.

00:00:12.160 --> 00:00:17.099
We're going to create classes that use frog,
truck, and grid to implement the logic of

00:00:17.099 --> 00:00:22.830
the game, and we're going to improve the frog,
truck, and grid classes. I've already done

00:00:22.830 --> 00:00:28.179
a little bit of improvement. I've added Javadoc
to the classes. Now to me this is just a matter

00:00:28.179 --> 00:00:33.079
of professionalism. I don't like looking at
code without Javadoc and I don't you to get

00:00:33.079 --> 00:00:37.510
used to looking at code without Javadoc in
it. At the same time, it does take a lot of

00:00:37.510 --> 00:00:44.510
time to write Javadoc and it's not very interesting,
so I decided to do it offline. Now our previous

00:00:45.710 --> 00:00:51.579
work has some very serious shortcomings: the
data in the frog, truck, and grid classes

00:00:51.579 --> 00:00:56.899
can be changed by other classes in the same
project. For example let's go and add a to

00:00:56.899 --> 00:01:00.769
string method to the frog class. We're going
to have a little problem with that that we'll

00:01:00.769 --> 00:01:05.810
talk about when we get there and create a
new class with a frog object and then move

00:01:05.810 --> 00:01:12.040
the class to the upper left corner by mutating
the data. So I've created a new project with

00:01:12.040 --> 00:01:19.040
our Frogger class in it. Let's create an example
class with a main method that we can use.

00:01:27.409 --> 00:01:32.579
Now this one I'm not going to document, because
this is just a test to see how things are

00:01:32.579 --> 00:01:39.579
working. So let's create a frog object and
let's start it at grid.rows-1 and grid.cols

00:01:45.299 --> 00:01:52.299
over 2. That's the place that our frog object
usually starts and then do a system out print

00:01:53.130 --> 00:02:00.130
line frog to see where our frog is. Now let's
move our frog. And print it out and make sure

00:02:11.730 --> 00:02:17.870
that our frog is where we think it is. Now
the first time we do it, it's not going to

00:02:17.870 --> 00:02:24.870
work. Well, it's working [laughs] but it's
not doing exactly what we wanted. What you're

00:02:26.360 --> 00:02:30.780
seeing here is the reference, and the reason
you're seeing that is because our frog class

00:02:30.780 --> 00:02:36.120
didn't have a to string method in it. So let's
go and put that to string method in the class.

00:02:36.120 --> 00:02:43.120
I've going to put this just below the instance
methods and above the main program that we

00:02:43.230 --> 00:02:50.230
used for testing. So we're going to display
the row and column for the frog. The method

00:02:56.260 --> 00:03:01.420
is to string, so it's going to return a string
of course, as all of our to string methods

00:03:01.420 --> 00:03:08.420
have. So what we're going to return is frog
row plus row plus col plus col. Now, you could

00:03:17.170 --> 00:03:21.250
put this in a string variable if you wanted
and it'd return that variable. This is just

00:03:21.250 --> 00:03:26.300
an abbreviated syntax that I like. Now you'll
notice I completed my return statement and

00:03:26.300 --> 00:03:32.130
Eclipse is still unhappy. Let's take a look
at the source of its dissatisfaction. You

00:03:32.130 --> 00:03:37.940
cannot reduce the visibility of an inherited
method from object and this overrides object

00:03:37.940 --> 00:03:44.940
to string. Hmmm, well that's not very easy
to understand. Here is the fix for it. Now

00:03:45.310 --> 00:03:49.960
you're not going to really understand why
has to be fixed that way just yet, but for

00:03:49.960 --> 00:03:54.230
now if you remember to make all of your to
string methods public you won't have a problem

00:03:54.230 --> 00:04:01.230
with it. So let's go back to our example class
and see how things are working. Ah, that looks

00:04:05.000 --> 00:04:10.680
better. So what we can see we've done is we've
changed the data for the frog outside of the

00:04:10.680 --> 00:04:16.130
frog class without getting the frog logic
involved. Remember our frog was only supposed

00:04:16.130 --> 00:04:20.620
to be able to go up, down, right, and left.
It's not supposed to hop to the corner in

00:04:20.620 --> 00:04:26.200
one step. So this really means that the design
of our frog class has failed, and we need

00:04:26.200 --> 00:04:32.790
to figure out a better way to do this. So
we added our to string method looking at that

00:04:32.790 --> 00:04:38.980
weird error message. We created a new frog
object. So what we now know is that our frog

00:04:38.980 --> 00:04:43.160
object's state is not being enforced. They
were supposed to jump only one position a

00:04:43.160 --> 00:04:47.130
time and they can jump anywhere in the world
they want! They don't even have to stay on

00:04:47.130 --> 00:04:53.280
the board. So really, this is a very serious
problem for object-oriented programming. Our

00:04:53.280 --> 00:05:00.280
frog class has no control whatsoever. So what
we need to do is to put in access modifiers.

00:05:00.410 --> 00:05:06.100
Now access modifiers are used for both data
and method. We have a private modifier, and

00:05:06.100 --> 00:05:11.410
that's used for things that should be inside
the class only and then we have a public modifier,

00:05:11.410 --> 00:05:17.060
and that means that anybody can use it. Now
what we have in our class now is nothing.

00:05:17.060 --> 00:05:22.510
The way Java handles that is with something
that's called package level access. In essence,

00:05:22.510 --> 00:05:27.180
any other class that's in the same directory
can use anything it wants in that class if

00:05:27.180 --> 00:05:32.400
you don't say otherwise. Well that just isn't
good enough as we've seen. Our example class

00:05:32.400 --> 00:05:37.500
was able to make our frog do things that frogs
shouldn't be able to do. So we need to go

00:05:37.500 --> 00:05:44.390
through and put correct access modifiers on
absolutely everything. Now the state of our

00:05:44.390 --> 00:05:50.000
objects is represented by data. If anyone
outside of the class can alter the data we

00:05:50.000 --> 00:05:55.080
can't enforce a legal state. So this means
that our data is almost always going to to

00:05:55.080 --> 00:06:00.520
be private. There is one exception to that,
and that's constants. You can make constants

00:06:00.520 --> 00:06:05.650
private and sometimes you should and you can
make them public. The way you figure it out

00:06:05.650 --> 00:06:10.420
is you have to think about whether somebody
outside of the class really needs to know

00:06:10.420 --> 00:06:14.889
about this constant. So let me give you an
example of something that's a constant that

00:06:14.889 --> 00:06:18.980
you've been using that you may not have known
about. You know in our ArrayList how when

00:06:18.980 --> 00:06:25.980
we construct a new ArrayList object it sets
an array of size 10? That 10 is a constant.

00:06:26.139 --> 00:06:30.200
It's not documented in the ArrayList, you
really don't know where it is, but believe

00:06:30.200 --> 00:06:35.340
me that's a constant somewhere. So that is
a constant that they made private. On the

00:06:35.340 --> 00:06:41.510
other hand things like integer max value,
interger min value, math.pi, these are constants

00:06:41.510 --> 00:06:45.650
that are public. Now you know they're public
'cause they're documented in the API. The

00:06:45.650 --> 00:06:52.650
API only documents public stuff. So it just
depends on the situation. If you're not sure,

00:06:53.610 --> 00:06:58.419
the conservative approach is to make everything
private. Now I've mentioned before that computer

00:06:58.419 --> 00:07:04.120
scientists tend to be conservative, and so
that's a great place to start. If later on

00:07:04.120 --> 00:07:08.980
somebody demands that that constant be public
you could make it public, but once you've

00:07:08.980 --> 00:07:13.530
made something public you cannot make it private
because if other people are using your code

00:07:13.530 --> 00:07:17.610
and depending on it, you are going to break
their code. And that's going to make them

00:07:17.610 --> 00:07:23.560
mad, so we just don't do that. Now method
and constructors are a little bit different.

00:07:23.560 --> 00:07:28.389
The state of our data should be changed only
through method invocations and construction,

00:07:28.389 --> 00:07:35.050
of course. So these things are what are controlling
the state of our data and it's the responsibility

00:07:35.050 --> 00:07:40.950
of those methods to make sure that data is
only changed in ways that are legally permitted.

00:07:40.950 --> 00:07:46.389
This means that methods are usually public.
Now notice usually, not always. Constructors

00:07:46.389 --> 00:07:52.310
are also usually public. Now there are some
notable examples particularly on constructors.

00:07:52.310 --> 00:07:58.199
You may have noticed that classes like arrays
and collections and math have no objects.

00:07:58.199 --> 00:08:02.020
When you have no objects you don't need a
constructor, and the way you handle that in

00:08:02.020 --> 00:08:07.370
Java is to make the constructor private. So
that's kind of a sneaky little trick. It comes

00:08:07.370 --> 00:08:13.210
in handy sometimes, though. So now we're going
to go and modify our existing classes. We're

00:08:13.210 --> 00:08:18.169
going to add our proper access modifiers to
the frog, the truck, and the grid. We're going

00:08:18.169 --> 00:08:25.169
to make all of our data private and all of
our methods public. So here's our frog class.

00:08:30.600 --> 00:08:37.560
Row is data so it's private; call is data
so it's private. Now we've got to decide about

00:08:37.560 --> 00:08:43.830
this symbol. Do we need to know this symbol
in another class? Well we absolutely do. And

00:08:43.830 --> 00:08:50.200
the reason we need to know it is so we're
able to create the object and the grid. So

00:08:50.200 --> 00:08:57.200
this is a case where constant has to be public.
We are going to build frog objects outside

00:08:57.589 --> 00:09:04.589
of the class, so that should be public and
all of these movement methods should be public.

00:09:12.050 --> 00:09:16.320
And of course our to string method already
was public. Now let's go back to our example

00:09:16.320 --> 00:09:23.080
class and see what happens. Notice what's
happened here. Example is no longer allowed

00:09:23.080 --> 00:09:28.300
to access row and column. It is allowed to
call the constructor. It is allowed to call

00:09:28.300 --> 00:09:35.300
to string, but this movement that created
the security violation? That's no longer allowed.

00:09:35.350 --> 00:09:41.130
So basically we've done what we wanted. Now
I'm going to remove the example object from

00:09:41.130 --> 00:09:47.900
this class permanently so that it doesn't
mess things up as we go along. So our frog

00:09:47.900 --> 00:09:53.390
class is now fixed. Let's go to our truck
class and do the same thing. So here's all

00:09:53.390 --> 00:10:00.390
of our data and all of this has to be private...lots
of private data. Our constructor should be

00:10:10.510 --> 00:10:17.510
public and our move method should be public.
So the truck class is now fixed. Now we're

00:10:20.070 --> 00:10:26.930
going to go to the grid class. Here's the
private data. Now the rows and columns, we're

00:10:26.930 --> 00:10:31.120
going to have to think a little about whether
they should be public or private. In order

00:10:31.120 --> 00:10:36.460
to implement this game correctly we do need
to know what those values are in other classes,

00:10:36.460 --> 00:10:43.120
and so these are public constants. By the
way these also could move to a different class.

00:10:43.120 --> 00:10:50.120
We're going to call the class controller,
so that's an option that's available. Here's

00:10:50.570 --> 00:10:55.399
our constructor. Remember we can tell it's
a constructor by two things: it doesn't have

00:10:55.399 --> 00:11:00.640
a return type and it has the same name of
the class. You do have to be careful with

00:11:00.640 --> 00:11:06.000
constructors for not doing this. Notice that
Eclipse was really not able to pick up what

00:11:06.000 --> 00:11:11.560
that problem was. It did raise a little yellow
flag and that's the method has a constructor

00:11:11.560 --> 00:11:16.120
name, so at least it gives you some warning,
but remember constructors don't have a return

00:11:16.120 --> 00:11:23.120
type. So clearing the grid will be public,
displaying the grid will be public, and setting

00:11:28.420 --> 00:11:33.970
the grid will be public. So we've just made
some major changes to this class, in fact

00:11:33.970 --> 00:11:38.300
to all of these classes, in terms of being
able to support them. Let's save the files

00:11:38.300 --> 00:11:43.070
and make sure that everything's okay. As you
know sometimes when Eclipse saves files bad

00:11:43.070 --> 00:11:49.580
things happen. So now we need to design our
controller data. Now all of our controller

00:11:49.580 --> 00:11:54.140
data is going to be private so we're going
to need a frog we're going to need a bunch

00:11:54.140 --> 00:11:59.110
of trucks, and we're going to need a grid.
We're also going to need a constructor that

00:11:59.110 --> 00:12:05.190
will build the frog, the bunch of trucks,
and the grid. Now in UML when we have a plus

00:12:05.190 --> 00:12:10.089
that means it's public and when we have a
minus it means it's private. So this is what

00:12:10.089 --> 00:12:15.980
the data for our controller class is going
to look like. Notice all of our data is public,

00:12:15.980 --> 00:12:21.029
the constructor, remember the one that's in
the bottom, I've made that public. And recall

00:12:21.029 --> 00:12:25.670
that we don't usually put constructors in
UML, that's not consistent with the standard,

00:12:25.670 --> 00:12:30.610
but I have found it awfully useful. Well now
we need to think about what other kind of

00:12:30.610 --> 00:12:35.230
methods we're going to need in order for this
to be successful. So the controller class

00:12:35.230 --> 00:12:39.279
is implementing the logic of the game. So
we need to think about what are sort of the

00:12:39.279 --> 00:12:43.790
big pieces of logic that we're going to need
to make this game work? So we're going to

00:12:43.790 --> 00:12:48.390
need to design the controller methods. Well
certainly we've got to be able to move the

00:12:48.390 --> 00:12:54.220
player somehow, so the trucks need to move
and the frog needs to move. So those are two

00:12:54.220 --> 00:12:59.110
methods we're definitely going to need. Remember
the frog is moved by the user, the trucks

00:12:59.110 --> 00:13:04.640
are just moved automatically. We also need
to figure out if the game ended and it turns

00:13:04.640 --> 00:13:09.730
out there are quite a few ways that Frogger
can end. One thing is the frog can win, it

00:13:09.730 --> 00:13:15.170
can get to the other side of the road. But
if the frog jumps out of bounds than the frog

00:13:15.170 --> 00:13:20.589
loses, and so that's something we're going
to have to check for. Also the frog could

00:13:20.589 --> 00:13:25.170
collide with the truck. That is, the frog
could jump into the truck or the truck could

00:13:25.170 --> 00:13:30.180
run over the frog, that is, the truck could
go into the frog and we've got to check for

00:13:30.180 --> 00:13:36.100
both of those cases. We also has be able to
show the user the game because it's no fun

00:13:36.100 --> 00:13:39.980
to play if you can't see what's going on.
So we're going to need to be able to clear

00:13:39.980 --> 00:13:46.980
the screen and to display the game. Now here
is a design in UML that covers the design

00:13:47.740 --> 00:13:52.320
of the controller class. We have the data
that we talked about last time: the frogs,

00:13:52.320 --> 00:13:58.550
the trucks, the grid. Then we have our constructor.
Now move truck looks like what you expected

00:13:58.550 --> 00:14:04.300
I'd guess, but move frog probably doesn't.
We've never seen an input stream reader before.

00:14:04.300 --> 00:14:09.110
It turns out this is part of dealing with
the problems that come about from using console

00:14:09.110 --> 00:14:14.410
for something that it really isn't designed
to do, namely play games, so we're going to

00:14:14.410 --> 00:14:19.110
have to do a little bit of manipulation. This
isn't such an interesting part of it or maybe

00:14:19.110 --> 00:14:23.339
it's the most interesting part if you're a
very experienced Java programmer, so we aren't

00:14:23.339 --> 00:14:27.330
going to spend too much time on it but I will
explain a little about why that decision had

00:14:27.330 --> 00:14:32.130
to be made. We've got to be able to figure
out whether the frog won. Notice I returned

00:14:32.130 --> 00:14:36.810
a Boolean there because either they won or
they didn't. Again, we have a Boolean returned

00:14:36.810 --> 00:14:41.860
from frog out of bounds and we have a method
that can tell if the frogs and trucks have

00:14:41.860 --> 00:14:47.399
collided. It also returns a Boolean. Clear
screen and display game, they both return

00:14:47.399 --> 00:14:52.490
void. So notice the pattern: the data are
all private, the methods and the constructors

00:14:52.490 --> 00:14:59.490
are all public. That is a very typical pattern
for many classes. So let's talk a little bit

00:15:00.399 --> 00:15:04.779
about this input stream reader and what the
heck happened with that. Well it turns out

00:15:04.779 --> 00:15:08.769
we can't use a scanner for this program and
that's too bad 'cause the scanner's really

00:15:08.769 --> 00:15:14.310
done great work for us. When you ask a scanner
objects for input from the keyboard it does

00:15:14.310 --> 00:15:19.750
something called blocking. What it does is
it waits for you to respond. Now in a way

00:15:19.750 --> 00:15:23.800
this is a good thing, because frankly if it
just went flying past you you'd be really

00:15:23.800 --> 00:15:29.269
mad, particularly 'cause computers move so
much faster than people do. The problem here

00:15:29.269 --> 00:15:34.000
is that when the scanner blocks, it stops
the game from executing. That is, the trucks

00:15:34.000 --> 00:15:38.940
can't move. Well if the frog is just sitting
there and the trucks aren't moving, it gives

00:15:38.940 --> 00:15:43.160
you an awful lot of time to figure out your
next move. In essence it makes the game no

00:15:43.160 --> 00:15:49.089
fun to play at all. So we had to find a way
to get input from the keyboard that doesn't

00:15:49.089 --> 00:15:53.260
block. Now this is far beyond the scope of
this class, of course. This is not something

00:15:53.260 --> 00:15:58.620
that would've been easy to figure out on your
own. So let me explained to you what the choice

00:15:58.620 --> 00:16:03.860
is. This input stream reader is a class that
doesn't block, and so that's a good one to

00:16:03.860 --> 00:16:09.040
use. In other words it's not going to wait
for input. The construction is similar to

00:16:09.040 --> 00:16:14.690
the scanner so that's kind of nice. It has
a ready method and ready doesn't lock, so

00:16:14.690 --> 00:16:18.670
it just tells you right now is there something
waiting for you or not? Well that's exactly

00:16:18.670 --> 00:16:24.470
what we need. It also has a read method although
the read method is kind of strange. What it

00:16:24.470 --> 00:16:29.810
does is it gets a single character, but it
returns an int. Well that's really a weird

00:16:29.810 --> 00:16:34.149
design decision. There are lots of reasons
for it, it's really beyond the scope of this

00:16:34.149 --> 00:16:39.180
class but we're going to have to remember
to do a cast in order to get that character

00:16:39.180 --> 00:16:43.610
back. So there are some details about the
input stream reader. Of course you can do

00:16:43.610 --> 00:16:49.300
some more investigations online if you want
to see more about this very interesting class.

00:16:49.300 --> 00:16:55.529
It turns out that I/O in Java can be a gigantic
pain in the neck it's very, very comprehensive,

00:16:55.529 --> 00:17:00.149
it's extremely well designed, it's a little
hard to use when you first learn it. You'll

00:17:00.149 --> 00:17:06.119
see it a lot in your next semester of Java
programming. So the next thing we need to

00:17:06.119 --> 00:17:10.429
do is implement our controller. So we're going
to implement the constructor, we're going

00:17:10.429 --> 00:17:17.059
to move the trucks, we're going to move the
frog. So here's our controller class. Inside

00:17:17.059 --> 00:17:23.230
the constructor your goal is to make sure
that all of the instance data is properly

00:17:23.230 --> 00:17:27.839
constructed. So let's label this instance
data, that was a shortcoming of our previous

00:17:27.839 --> 00:17:34.839
documentation and construct the objects. So
grid equals new grid. Frog equals new frog,

00:17:39.909 --> 00:17:44.720
now we have to decide where to place the frog.
Remember, we were going to put it at the bottom.

00:17:44.720 --> 00:17:51.720
So that's grid.rows-1 and halfway across the
board. So there we've constructed our frog

00:17:57.100 --> 00:18:04.100
and now we need to construct our array of
trucks. So it needs to be an array of trucks,

00:18:08.239 --> 00:18:13.419
and we need to think about how many trucks
we want. Well we want one truck in every row

00:18:13.419 --> 00:18:18.980
of the game. But remember we have the starting
and the ending platforms for the frog, so

00:18:18.980 --> 00:18:25.980
it'll be grid.rows-2. 
We've constructed the reference for the truck
array, we have constructed the truck array,

00:18:32.080 --> 00:18:37.950
but what we haven't constructed is the individual
trucks, and so we need to construct those.

00:18:37.950 --> 00:18:44.950
This is the two-layer construction process
that's necessary with arrays of objects. So

00:18:45.409 --> 00:18:52.409
we're going to need to use a loop. I is zero,
i less than trucks.length++i. So we'll say

00:18:59.059 --> 00:19:06.059
trucks of i equals new truck, and now we need
to give its location on the grid. Well, it'll

00:19:08.809 --> 00:19:14.080
be i +1 because remember our first truck is
going to be in the first line, it's not going

00:19:14.080 --> 00:19:19.269
to be in the safety zone for the truck. And
then we have to find a random location for

00:19:19.269 --> 00:19:26.269
it, that is, a column where it belongs. So
that will be math.random times grid.cols.

00:19:32.200 --> 00:19:36.690
Random is a method of course so we had to
put parentheses after it and we can Eclipse

00:19:36.690 --> 00:19:42.179
is now not happy. The problem is that remember
random returns a double so when we multiply

00:19:42.179 --> 00:19:49.179
by an integer we get a double. So we're going
to need to cast that. And we need to think

00:19:51.649 --> 00:19:58.649
about whether that's going to be off by one
or not. Looks to me like I may be off by a

00:19:59.799 --> 00:20:06.799
parentheses, so let's do some counting I have
1, 2, 3, 4 left parentheses 1, 2, 3, 4 right

00:20:12.320 --> 00:20:19.320
parentheses. So that looks okay. Well isn't
that funny. What could possibly be the problem

00:20:20.389 --> 00:20:27.389
there? We've cast grid.columns times math.random.
Well I guess we could always go and look the

00:20:29.950 --> 00:20:36.359
error message. "The constructor truck int
int is undefined." Well that's kind of odd.

00:20:36.359 --> 00:20:42.299
Let's go look at our truck constructor, ah!
Well I think I see what the problem is. Remember

00:20:42.299 --> 00:20:45.799
we have to decide if the truck is going to
go to the right or to the left, and I had

00:20:45.799 --> 00:20:52.799
apparently forgotten that. So let's create
a Boolean is right and give it the value of

00:20:56.899 --> 00:21:03.899
math.random less than 0.50. There we go, now
our truck constructor is happy. So we've gone

00:21:14.989 --> 00:21:20.299
through every single piece of instance data
and made sure it was correct. You'll notice

00:21:20.299 --> 00:21:26.289
that I'd also have not handled our data correctly
here. And that's that I haven't made our data

00:21:26.289 --> 00:21:31.039
private and our methods public. So we're going
to have to go through the whole class and

00:21:31.039 --> 00:21:37.940
fix that. This larger than console size--
that's something we're going to use a little

00:21:37.940 --> 00:21:43.239
bit later on. I'm going to take the conservative
approach and make it private. We can decide

00:21:43.239 --> 00:21:50.239
later if we need to be public. So here's our
constructor. Here is move trucks, here's frog

00:21:55.840 --> 00:22:02.840
one. You'll notice I've got some things commented
out there, don't worry about those just yet.

00:22:05.710 --> 00:22:12.710
We've got clear screen. We've got display,
frog and trucks collide, so there we go. Our

00:22:21.749 --> 00:22:28.749
controller class now has the correct protections
on it, and the ones that were in our design.

00:22:30.700 --> 00:22:36.919
So let's continue to go down and follow up
with this. So we have move trucks, so that's

00:22:36.919 --> 00:22:41.489
going to move trucks either to the right or
to the left. Now what you may or may not remember

00:22:41.489 --> 00:22:45.600
'cause it's been a few days since we looked
at the truck class is that all of that is

00:22:45.600 --> 00:22:50.129
actually handled inside the truck class. The
truck class knows which way each truck is

00:22:50.129 --> 00:22:57.129
going and moves it in the correct direction.
So the only thing we need to do here is to

00:22:59.029 --> 00:23:06.029
call the truck stop move method for each truck.
So trucks of i.move. Now that's one way to

00:23:10.529 --> 00:23:17.529
do it. If that doesn't make sense to you,
here's another possibility. Whoops! That should

00:23:19.859 --> 00:23:26.859
be an equals sign. And that's to create a
reference for that truck object and then move

00:23:28.830 --> 00:23:35.830
it. Either way is just fine, of course it's
more fine if you put the "s" on trucks so

00:23:38.029 --> 00:23:44.259
the compiler is happy with it. The first way
makes sense to me, but if it doesn't quite

00:23:44.259 --> 00:23:51.259
make sense to you yet, maybe this one is better.
Let's work with move frog that's our next

00:23:53.070 --> 00:23:57.419
method. Now this is the part that I've done
that the input stream reader. Like I say,

00:23:57.419 --> 00:24:02.179
I don't really expect you to understand an
input stream reader very well at this point,

00:24:02.179 --> 00:24:07.320
so I left the code here. So we look to see
if it's ready yet. If it's ready we read this

00:24:07.320 --> 00:24:12.320
one character. Now the reason we have to have
put this char cast in front of it is because

00:24:12.320 --> 00:24:18.179
read returns an integer, kind of a weird decision,
either way we're just going to work with it.

00:24:18.179 --> 00:24:25.179
So to move the frog we have to do a bunch
of nested if's. So if the letter equals equals

00:24:28.869 --> 00:24:35.869
a capital W or the letter equals equals a
little w. Remember the w key was what we were

00:24:38.950 --> 00:24:45.950
using to go up. So we'll do frog.move up.
Else if the letter equals a, whoops. Single

00:24:54.409 --> 00:25:00.169
quotes not double quotes because these are
characters not strings. Remember that's why

00:25:00.169 --> 00:25:05.859
we can use the equals equals instead of having
to use the equals method. So a was going to

00:25:05.859 --> 00:25:12.859
the left, s is down, and d is move right.
I see that I put double quotes up here instead

00:25:51.039 --> 00:25:58.039
of single quotes. There we go, now Eclipse
looks happy. Now you might want to think about

00:25:58.460 --> 00:26:02.929
whether you want to have another else here,
one that would catch all the other possibilities

00:26:02.929 --> 00:26:07.090
and maybe print out an error message to the
user. Stuff like that tends to be kind of

00:26:07.090 --> 00:26:11.409
annoying in a game. So basically if you use
a key that isn't the right key it's probably

00:26:11.409 --> 00:26:15.840
best for the game just to annoy it rather
than to constantly be pestering the user about

00:26:15.840 --> 00:26:21.279
little mistakes. That's just a matter of keeping
the game fun to play. Now the last thing we

00:26:21.279 --> 00:26:26.820
have to do in here is to read any other input
that's available. As long as we're in this

00:26:26.820 --> 00:26:31.970
method, the user could be actually typing
things in and so we want to make sure that

00:26:31.970 --> 00:26:36.450
we kind of eat up all that stuff. Specifically
we want to make sure we eat up the new line

00:26:36.450 --> 00:26:40.149
that's going to be after the letter we want
to read, because if we don't do that we're

00:26:40.149 --> 00:26:45.359
really in trouble. So that's what's going
on with that while loop. So moving the frog

00:26:45.359 --> 00:26:52.359
was pretty easy. Now here's the next thing
we need to do. We need to write the frogs

00:26:54.229 --> 00:26:58.710
and trucks collide method. To do this we're
going to have to end up modifying the frog

00:26:58.710 --> 00:27:05.710
and truck classes. So here we go back to our
code. Here is frog and trucks collide. So

00:27:12.179 --> 00:27:17.210
what we need to do is to figure out if the
location of the frog is also the location

00:27:17.210 --> 00:27:24.210
of the trucks. So where is the frog? Well,
we know it's at frog.row and frog.column.

00:27:27.809 --> 00:27:33.179
But when we try to put that in we see we've
got a problem. Notice the field frog.row is

00:27:33.179 --> 00:27:38.619
not visible. Well we know it's not visible,
we made it private a few minutes ago. So we've

00:27:38.619 --> 00:27:44.440
really got an issue and that's that the frog
is concealing something that we need to use.

00:27:44.440 --> 00:27:49.149
So we're going to have to add some methods
to the frog class to get what we need. Now

00:27:49.149 --> 00:27:54.259
these methods are called accessor methods
and we're going to need one for the row and

00:27:54.259 --> 00:28:01.259
one for the column. By convention they're
called get so get row and get column. So return

00:28:01.820 --> 00:28:08.820
the row location of the frog and we will have
public int get row and we're going to return

00:28:16.129 --> 00:28:23.129
row. And then we'll return the column location
of the frog, public int get call. Now sometimes

00:28:33.929 --> 00:28:37.609
this process really bugs students, 'cause
they're like well if you're just going to

00:28:37.609 --> 00:28:42.389
give me access to the data, why did we make
the data private in the first place? Well

00:28:42.389 --> 00:28:47.419
notice I'm giving you access to the data.
I'm not allowing you to change it. So letting

00:28:47.419 --> 00:28:52.359
somebody else use the data is different than
letting them change it. By creating private

00:28:52.359 --> 00:28:58.119
data and creating accessors, that makes it
possible to give people a copy of your data

00:28:58.119 --> 00:29:05.119
without letting them mess up your frog. So
this is how we enforce encapsulation in classes.

00:29:05.129 --> 00:29:09.849
Let's go to the truck class. Now we need to
think about what we actually need to access

00:29:09.849 --> 00:29:14.729
here, because we don't maybe need to access
everything. We certainly need the row. We

00:29:14.729 --> 00:29:18.969
need the left column; we need the right column.
We're going to need the symbol too, because

00:29:18.969 --> 00:29:24.190
the symbol is what's going to be displayed
on the grid. But we really don't need is right

00:29:24.190 --> 00:29:30.039
or is left. So we're only going to have to
make for accessors here not five. You always

00:29:30.039 --> 00:29:34.609
want to make the minimum number of accessors
possible, and then you can add in more later

00:29:34.609 --> 00:29:41.609
if you actually need them. So I'm going to
put the accessors down here. So we'll have

00:29:42.849 --> 00:29:49.849
public int get row. Now I'm not Javadocing
these right at the moment. I will Javadoc

00:29:51.899 --> 00:29:56.940
them before I put them up for your review
just to save us a little bit of time. So we'll

00:29:56.940 --> 00:30:03.919
have get right column, remember our trucks
take up two positions, so we're going to have

00:30:03.919 --> 00:30:10.919
to return both of them. We could decide that
we only wanted to return one and then figure

00:30:12.259 --> 00:30:16.649
out based on whether it's right or left where
the other one should be, but I think that

00:30:16.649 --> 00:30:23.649
that's probably not such a great idea. This
better encapsulates the class. So we'll need

00:30:24.179 --> 00:30:31.179
public char get symbol to, and here we're
returning symbol. Remember the reason that

00:30:31.950 --> 00:30:36.460
that couldn't be class data like it was in
the case of the frog class is because sometimes

00:30:36.460 --> 00:30:40.539
we're using a greater than sign for trucks
that are going right and then we're using

00:30:40.539 --> 00:30:45.759
a less than sign for trucks that are going
left. So there we have all of our little methods.

00:30:45.759 --> 00:30:52.309
So we've given the controller access to things
that still force the trucks and the frogs

00:30:52.309 --> 00:30:59.309
to behave the rules. So that's a good thing!
We now can see that if frog.rowâ€”sorry get

00:31:06.940 --> 00:31:12.820
row, the method. Well we're going to need
to compare it to all five trucks. I think

00:31:12.820 --> 00:31:18.830
maybe we'd better put a loop in here to make
this a little bit easier. I is zero, i less

00:31:18.830 --> 00:31:25.830
than trucks.leng plus plus i. So if frog.get
row equals trucks of i.get row. So that means

00:31:35.460 --> 00:31:42.460
they're in the same row, and now here's where
we need to be careful. If the frog hits either

00:31:42.919 --> 00:31:47.389
one of the columns where the truck is, it's
going to get squashed. So we need to make

00:31:47.389 --> 00:31:54.389
sure we check both of them. But it's going
to be an or instead of an and. So frog.getCol

00:31:54.549 --> 00:32:01.549
equals trucks of i.get right col or frog.getCol
equals trucks of i.get left call. So if it's

00:32:21.489 --> 00:32:26.039
in either one of those that's going to be
true. Now you might think yourself, "Do we

00:32:26.039 --> 00:32:31.659
need this last set of parentheses or not?"
Well remember and has higher precedence than

00:32:31.659 --> 00:32:36.349
or, so if we don't put the parentheses in
here, we're going to have a problem. So yes

00:32:36.349 --> 00:32:42.570
these parentheses are actually necessary.
Well if any one of those things happened then

00:32:42.570 --> 00:32:47.609
we return true immediately we don't have to
go on any further. Oops, looks like I forgot

00:32:47.609 --> 00:32:54.019
an index in my array. That's not going to
work. If we get to the end of the loop and

00:32:54.019 --> 00:33:00.789
none of these collisions have happened, that's
when we'll return false. So that's a very

00:33:00.789 --> 00:33:05.969
concise way to write that method. So notice
we had to go and actually fix our frog and

00:33:05.969 --> 00:33:10.049
truck class in order to actually make this
possible. Now we might think about our grid

00:33:10.049 --> 00:33:15.899
class too, 'cause we're certainly going to
have that problem. So let's go to the grid

00:33:15.899 --> 00:33:22.899
class and see where we might be in trouble.
Well, clear grid is fine. And display the

00:33:24.059 --> 00:33:29.989
grid is fine, so that's showing the whole
grid at once, and we can set the grid. Notice

00:33:29.989 --> 00:33:35.210
we're not able to get things out of the grid.
Well maybe we don't need to. Let's think about

00:33:35.210 --> 00:33:41.289
whether that's necessary or not before we
jump too far ahead. Going back to our controller,

00:33:41.289 --> 00:33:48.289
we're going to do our display method. So clearing
the screen will be grid.clear grid, whoops!

00:33:51.469 --> 00:33:58.469
Sorry that's emptying the grid, that's the
next phase. Clearing the screen is in this

00:34:02.309 --> 00:34:08.830
class and it's called clear screen. Notice
that I don't have to put an object in front

00:34:08.830 --> 00:34:13.850
of it, because we're in an instance method
and clear screen is also an instance method.

00:34:13.850 --> 00:34:18.220
If you feel uncomfortable not having an object
there the object that should be there is called

00:34:18.220 --> 00:34:23.480
"this". That's that implicit object thing
that we've talked about every now and then.

00:34:23.480 --> 00:34:30.480
Now we need to put the frogs and the trucks
into the grid. So that will be grid.set, oh

00:34:32.560 --> 00:34:39.560
what was the name of that method? Set grid,
row, column and symbol. Well the row will

00:34:43.280 --> 00:34:50.280
be frog.get row. The column will be frog.get
column, and the symbol will be frog.symbol.

00:34:57.330 --> 00:35:02.780
Now notice I didn't use a frog with a little
f because symbol is class data, and so that

00:35:02.780 --> 00:35:07.810
was a little nicer way to do it. It would
still work if you put the little f in frog,

00:35:07.810 --> 00:35:12.320
it's just not quite as perfect and as you've
probably picked up, I like code to be very,

00:35:12.320 --> 00:35:18.830
very, very perfect. Now we've got a whole
bunch of trucks, so let's use a loop to work

00:35:18.830 --> 00:35:25.830
with them. So i less than zero, i less than
trucks.length plus plus i and we'll do grid.set

00:35:30.990 --> 00:35:37.990
grid trucks of i.get row trucks of i.get left
column. Remember with trucks, the symbol is

00:35:49.630 --> 00:35:56.630
actually instance data, so we'll use get symbol.
And then we need to do the same thing for

00:36:01.490 --> 00:36:08.490
the right column. So let's just copy it and
paste it. So we've got our frog, we've got

00:36:20.610 --> 00:36:27.610
our trucks, and now we need to show the grid.
So that should be in the grid class and it

00:36:27.780 --> 00:36:33.560
looks like the method is called display. I
think I'd like to call that display grid instead

00:36:33.560 --> 00:36:39.550
of just display because I think it makes more
sense since we're just using our controller

00:36:39.550 --> 00:36:46.550
now. So we'll do grid.display grid. Now if
we were further along we might not want to

00:36:50.870 --> 00:36:56.120
make changes like that to that method name,
because it's going to tend to break things.

00:36:56.120 --> 00:36:59.830
Now one thing you may have noticed at this
point is we've been writing a tremendous amount

00:36:59.830 --> 00:37:04.650
of code without checking it. It's an incredibly
bad idea. We would've been much smarter to

00:37:04.650 --> 00:37:09.430
test every method as we went along by putting
a main program in the controller class and

00:37:09.430 --> 00:37:16.230
making sure that everything is still working.
So we've made our display game method by clearing

00:37:16.230 --> 00:37:20.780
the grid, putting the frog and trucks in the
grid, and then showing the grid to the user.

00:37:20.780 --> 00:37:25.860
So our controller class is now implemented.
Well, it's sort of implemented. I actually

00:37:25.860 --> 00:37:32.860
made some changes earlier that I need to unmake.
You may have noticed them as we were scrolling

00:37:32.990 --> 00:37:39.990
around. Because I wrote this at a time when
we didn't have the accessor methods in...we

00:37:42.950 --> 00:37:46.710
need to make sure that we get those comments
out of there. Otherwise, our game isn't going

00:37:46.710 --> 00:37:53.060
to work at all. Those things are easy to forget
sometimes if you leave them over on the left-hand

00:37:53.060 --> 00:38:00.060
side it makes it a little bit easier to remember
that you need to do it as you move around.

00:38:00.380 --> 00:38:06.820
Okay! Now we're finally to the point where
we can create the class that has the game

00:38:06.820 --> 00:38:12.530
in it. Now there are two possible choices
we can make here. One is to put the main method

00:38:12.530 --> 00:38:17.670
in the controller class. Now I've done that
with students before and it tends to run into

00:38:17.670 --> 00:38:22.250
problems. People seem to get confused when
there's a controller object inside the controller

00:38:22.250 --> 00:38:28.080
class, and so I tend not to do it that way.
Another way to do it is in a separate driver

00:38:28.080 --> 00:38:33.260
class, and I found that students seem to have
more success when they do it that way. We

00:38:33.260 --> 00:38:37.500
can use the methods in the controller class
to implement the game. I'm actually going

00:38:37.500 --> 00:38:42.470
to show you this already finished just to
save us some time here, because it's not very

00:38:42.470 --> 00:38:48.980
hard to do. So let's look at the driver class.
You'll notice all it has is a main program.

00:38:48.980 --> 00:38:54.050
Now it has to create the input stream reader--
that's so that we can interact with the user,

00:38:54.050 --> 00:38:59.980
and notice that that comes from system.in.
So it works like the scanner class does. Now

00:38:59.980 --> 00:39:06.980
I construct a controller object and then I
display the game. I also print out the prompt

00:39:07.190 --> 00:39:12.940
for the user about how the interaction works
to give them a chance to play it. Now here's

00:39:12.940 --> 00:39:17.740
the main loop where the game is played. Notice
it's a while true, so it's basically an infinite

00:39:17.740 --> 00:39:24.340
loop. So anytime this game stops, whether
the frog wins or loses, we're going to have

00:39:24.340 --> 00:39:28.590
a system exit. That's not always the nicest
way to implement it because remember often

00:39:28.590 --> 00:39:32.420
people will want to play a game more than
once, but we're going to keep it simple for

00:39:32.420 --> 00:39:37.590
now. I mean we're doing ASCII art and we're
using a console for a game, so, you know,

00:39:37.590 --> 00:39:40.640
we've clearly decided that this isn't going
to to be the greatest game on the face of

00:39:40.640 --> 00:39:44.950
the planet when you make those decisions.
So the first thing you want to do is to let

00:39:44.950 --> 00:39:50.950
the user move the frog. So notice that's encapsulated
in the move frog method, and it does need

00:39:50.950 --> 00:39:57.550
to have the input there. Then we see if the
frog has won. If the frog has won, we show

00:39:57.550 --> 00:40:01.840
the final state of the game. Now the first
time I wrote this I actually didn't put that

00:40:01.840 --> 00:40:06.660
in, and it was so frustrating to play. Because
even though you saw that you'd won you didn't

00:40:06.660 --> 00:40:11.859
see the frog hit the far line. So you always
have to think about when you're writing games

00:40:11.859 --> 00:40:15.470
- what's going to make it fun? What does the
user want to see? So you don't want to leave

00:40:15.470 --> 00:40:19.660
them dissatisfied, 'cause there are lots of
other games they can go and play. Then we

00:40:19.660 --> 00:40:25.240
say system exit 1. So a system exit 1 just
means that everything's fine. When things

00:40:25.240 --> 00:40:32.080
are in a failure mode you do system exit of
0. The next thing you have to check to see

00:40:32.080 --> 00:40:38.420
if the frog jumped into a truck. So there
we call our frog and trucks collide. If the

00:40:38.420 --> 00:40:43.510
frog jumped into a truck, the game is over,
no doubt about that. Then you need to allow

00:40:43.510 --> 00:40:49.210
the trucks to move. So that lets the trucks
roll over the frog. Sorry if this is getting

00:40:49.210 --> 00:40:55.240
graphic. So we need to then check for intersections
and see if the frog got run over, so that's

00:40:55.240 --> 00:41:00.910
exactly the same code. Now, if you get to
this point, we know that the user hasn't won

00:41:00.910 --> 00:41:05.460
and they haven't lost. So at that point you
need to show the new state of the game to

00:41:05.460 --> 00:41:11.780
the user. Print out the instructions so that
they know what they're supposed to do still,

00:41:11.780 --> 00:41:16.890
always nice to keep that on the screen and
then we have to pause. Now I'm going to run

00:41:16.890 --> 00:41:23.890
this once without the pause so you can see
why pausing is necessary. Oh, we've got a

00:41:28.770 --> 00:41:35.770
problem. Well see our failure to debug this
program is killing us. So we're in the grid

00:41:38.200 --> 00:41:45.200
class and we've got an illegal grid position
set. We know something's going wrong here

00:41:49.270 --> 00:41:56.250
with set grid. Let's first off make sure that
this method isn't the problem. So r should

00:41:56.250 --> 00:42:03.250
be between 0 and rows, and c should be between
0 and columns. That looks correct there. Now

00:42:06.390 --> 00:42:11.800
we can see we've really got a problem here
because we don't know what is doing the illegal

00:42:11.800 --> 00:42:17.570
move. We know it's either a frog, well actually,
you know what we do know that it's not a frog

00:42:17.570 --> 00:42:22.360
if we think about it a little bit. Because
our frogs aren't doing anything yet. We didn't

00:42:22.360 --> 00:42:26.820
even get around to entering any user input,
so it's got to be the trucks that are going

00:42:26.820 --> 00:42:33.820
out of bounds. So let's look at our move method
and our truck class and see what's up. Well,

00:42:36.540 --> 00:42:41.670
I think I see what the problem is. Did we
ever check to see if our trucks went out of

00:42:41.670 --> 00:42:48.380
bounds? Well, we really didn't. When we move
right we can't just move to the right column

00:42:48.380 --> 00:42:53.610
plus 1 or to the left column minus 1, that
doesn't work. We need to wrap around so that

00:42:53.610 --> 00:42:57.250
our trucks just don't disappear. Otherwise
they just drive off the screen and the frog

00:42:57.250 --> 00:43:01.660
can hop across the road at its leisure. So
we've definitely got a problem here we need

00:43:01.660 --> 00:43:07.830
to deal with. So let's think about how we
can deal with it. The easiest way when we're

00:43:07.830 --> 00:43:14.830
adding 1 is like this: left column +1 mod
grid.calls. So what that means is when we

00:43:20.890 --> 00:43:27.080
hit grid.cols it will wrap around back to
0. So that's a pretty elegant solution for

00:43:27.080 --> 00:43:33.240
moving right. Now it's probably pretty tempting
to use that solution on moving left, but it

00:43:33.240 --> 00:43:37.650
turns out it doesn't work. And the reason
is the mod operator when it encounters a negative

00:43:37.650 --> 00:43:42.920
number gives a negative value, and so that's
kind of a problem. So what we're going to

00:43:42.920 --> 00:43:49.920
have to do is something different if left
col equals-1, -1 'cause that will be when

00:43:50.830 --> 00:43:57.830
it goes out of range, then we're going to
do left col equals grid.cols-1. And of course

00:44:02.450 --> 00:44:09.450
we'll have to do the same thing for the right
col. So the left, when we're going to the

00:44:17.320 --> 00:44:24.320
right, we wrap around to 0, and when we're
going to the left, we wrap around the cols.

00:44:26.410 --> 00:44:31.940
Okay. Now see we would have found that sooner
if we had done a little bit of testing before

00:44:31.940 --> 00:44:38.940
now. Might not have been quite so disappointed
by our game at that point. Here we go. Now

00:44:40.640 --> 00:44:45.630
does this game look any fun to play to you?
The problem is the computer is moving forward

00:44:45.630 --> 00:44:51.080
so quickly that we really can't tell how to
play the game at all. In fact, it's completely

00:44:51.080 --> 00:44:57.050
unplayable at this point. What we need to
do is this - we need to actually put the game

00:44:57.050 --> 00:45:03.460
to sleep for a little period of time to give
the user a chance to respond. So our pause

00:45:03.460 --> 00:45:10.260
in milliseconds, that's a constant and notice
that I set it to 500. Now a millisecond is

00:45:10.260 --> 00:45:15.300
one thousandth of a second, so I'm putting
a half a second pause in here. That seemed

00:45:15.300 --> 00:45:20.060
to be about right on my computer and with
my response times. If you're a gamer you may

00:45:20.060 --> 00:45:24.410
find that a little bit laggy, so let's take
that out and see if our game looks like it's

00:45:24.410 --> 00:45:31.410
a little bit more fun to play. Okay, so now
we can see our trucks moving along and we

00:45:36.520 --> 00:45:42.670
need to move our frog. Notice I waited until
our trucks went past. Also do notice to you

00:45:42.670 --> 00:45:49.670
have to hit return, and that just has to do
and there we go. I think this might be a little

00:45:50.300 --> 00:45:53.880
bit more fun if I gave us a little bit more
space so you could actually see things like

00:45:53.880 --> 00:46:00.880
the directions. Oh, I know what's wrong there.
I had my cursor up there when I typed my first

00:46:05.670 --> 00:46:12.670
w to move my frog, easy mistake to make. Okay
so we're going to move our frog up and now

00:46:17.900 --> 00:46:24.900
I'm going to let the truck run over the frog.
And our game is over. Well that's good. Now

00:46:28.260 --> 00:46:35.260
let's try to hop off the board. So I'm going
to do an s instead of a w, and we can see

00:46:39.510 --> 00:46:44.770
we've got a little problem here because it
didn't detect that I was off the board. It

00:46:44.770 --> 00:46:51.770
did complain that there was an illegal grid
position. So we've got a little problem there

00:46:53.310 --> 00:46:59.990
that we're going to have to work with. So
we need to think about which class this is

00:46:59.990 --> 00:47:04.370
going to be in. So this is a problem with
figuring out that the frog has hopped off

00:47:04.370 --> 00:47:11.370
the board. Well when the frog hops off the
board, which should not survive, so frog out

00:47:23.070 --> 00:47:29.830
of bounds. So let's see what happens here.
Frog.get row is less than 0 or greater than

00:47:29.830 --> 00:47:35.940
or equal to grid.rows. Well that all looks
good, I guess the question is did we call

00:47:35.940 --> 00:47:42.940
the method? So let's take a look. Well, here's
where we moved the frog and we didn't check

00:47:45.950 --> 00:47:52.950
to see that it was out of bounds. So if controller.frog
out of bounds, well that's yet another way

00:47:58.460 --> 00:48:04.120
that we can lose. Now we don't want to display
the screen at this point because the frog

00:48:04.120 --> 00:48:08.200
isn't going to be visible and we are going
to get an error message, so we'll do system

00:48:08.200 --> 00:48:15.200
out print line 
and then system exit 1. So let's see if that
works better now. Okay, so here we go again.

00:48:45.830 --> 00:48:52.830
So now I enter an s and our game is over,
and notice we didn't get the error message.

00:48:56.020 --> 00:48:59.630
Remember the purpose of that error message
was not to communicate to the user it was

00:48:59.630 --> 00:49:03.890
to let us know that something went wrong.
Now you can play this game and it wouldn't

00:49:03.890 --> 00:49:08.400
surprise me if you find some other bugs in
it. I know the usability isn't great, but

00:49:08.400 --> 00:49:15.400
it is kind of fun. The pause was done to slow
things down, to keep the game from being unplayable,

00:49:17.550 --> 00:49:23.230
so we demonstrated all that stuff flying by,
absolutely worthless. So when you give the

00:49:23.230 --> 00:49:28.060
user time to read the game board, you have
to put it to sleep and that's what creates

00:49:28.060 --> 00:49:33.100
the lag in the game. So this is going to be
kind of annoying to play. If you shorten the

00:49:33.100 --> 00:49:37.430
pause, what's going to happen is the trucks
are going to move faster. So you have to sort

00:49:37.430 --> 00:49:43.810
of balance how fast the trucks can move to
be fair to the user and then how much lag

00:49:43.810 --> 00:49:48.440
you're willing to tolerate. It's not an easy
choice. Obviously this game would be a lot

00:49:48.440 --> 00:49:54.360
more fun if we had done a graphical user interface.
So let's now talk about the big picture a

00:49:54.360 --> 00:50:00.070
little bit. Our original design for the frog,
truck, and grid class was missing some critical

00:50:00.070 --> 00:50:04.350
methods. It didn't have the accessors, but
what's more it had data that was accessible

00:50:04.350 --> 00:50:10.450
to other classes, and that is just not going
to work. So we needed to make our data private

00:50:10.450 --> 00:50:16.470
and create accessor methods. Now not all data
gets accessor methods. Sometimes people get

00:50:16.470 --> 00:50:21.360
lazy and just get it into the habit of putting
them all in there but that isn't incorrect.

00:50:21.360 --> 00:50:27.180
So constants can be public and so they don't
need an accessor. Some data doesn't need to

00:50:27.180 --> 00:50:32.520
be known by the external world, so the example
of that was is right in the truck class. That

00:50:32.520 --> 00:50:37.370
had to do with how the truck moved. It isn't
something that the world needs to know, so

00:50:37.370 --> 00:50:42.150
you don't just go and routinely put in every
accessor. You really have to think, "Does

00:50:42.150 --> 00:50:46.220
somebody else need to know this or not?" The
other thing I want you to notice about our

00:50:46.220 --> 00:50:51.080
designs is now that we have instant methods
our method signatures are much more simple

00:50:51.080 --> 00:50:57.960
and elegant. They look a lot more like the
API, where you know every method has 2, 3

00:50:57.960 --> 00:51:02.850
maybe some methods have 4 or 5 parameters,
but you don't end up with these huge long

00:51:02.850 --> 00:51:09.500
list of parameters. This is what using instance
data is doing for us: the smaller number of

00:51:09.500 --> 00:51:14.480
parameters, a lot more void return types.
So our method signatures are getting much

00:51:14.480 --> 00:51:21.010
more simple. Now the reason this is happening
is because classes encapsulate data and objects

00:51:21.010 --> 00:51:26.350
and so once the data is encapsulated you only
need to use the object name. The skills we're

00:51:26.350 --> 00:51:30.820
working on now are the skills that make it
possible to create large-scale programming,

00:51:30.820 --> 00:51:35.520
and so there really important skills to develop
even though they are a little bit hard, particularly

00:51:35.520 --> 00:51:40.440
on the design side. The implementation side
is actually getting easier. Pay attention

00:51:40.440 --> 00:51:44.680
to that when you think about how hard the
designs are. So keep programming!

